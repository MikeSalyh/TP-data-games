<?xml version="1.0" encoding="utf-8"?>
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009"
			   xmlns:s="library://ns.adobe.com/flex/spark"
			   xmlns:mx="library://ns.adobe.com/flex/mx"
			   minWidth="745" minHeight="410" backgroundColor="#EAD1AA" creationComplete="startUp()"
			   pageTitle="Chain Saw">
	
	<fx:Script>
		<![CDATA[
			import chainsaw.GameLevelWindow;
			
			import chainsaw_assets.*;
			
			import com.kcpt.scriptInterface.ScriptInterface;
			
			import flash.media.Sound;
			import flash.media.SoundMixer;
			
			import mx.core.UIComponent;
			import mx.managers.CursorManager;
			import mx.managers.CursorManagerPriority;
			import mx.managers.PopUpManager;
			
			import spark.components.TitleWindow;
			import spark.core.SpriteVisualElement;
			import spark.events.TextOperationEvent;
			
			public var flashGasTank:MovieClip;
			public var sawdustParticles:ParticleLauncherXYFloor = new ParticleLauncherXYFloor();
			public var dynamicLog1:MovieClip;
			public var dynamicLog2:MovieClip;
			public var dynamicLog3:MovieClip;
			public var dynamicLog4:MovieClip;
			
			public static const VERSION:String 			= "Chainsaw [F] 2012.03.07"; // A string containing the version number (should be manually incremented for each build)
			
			public static const kTimeLimit:Number		= 20;		// Number of seconds player has to cut logs.
			public static const kUpdatesPerSecond:Number= 4;		// Fuel tank updates per second.
			public static const kTotalUpdates:Number	= kTimeLimit * kUpdatesPerSecond; // Total number of updates.
			public static const kUpdateInterval:Number	= 1000 / kUpdatesPerSecond; // Milliseconds between updates.
			public static const kReferenceLength:Number	= 75;		// Reference length in pixels of 16" piece.
			public static const kPercentAllowance:Number= ((1.0/8.0)*100);		// Percent allowed above or below accepted cut length.
			public static const kConvertToInches:Number	= 16.0/kReferenceLength;// Used to convert pixel length to 16".
			public static const kFuelCapacity:Number	= 40;		// Units of fuel when full.
			
			// Levels
			public static const kPracticeLevel:uint		  = 0;		// Practice level.
			public static const kDirectionalCutLevel:uint = 1;		// Directional cut level.
			public static const kFreeCutLevel:uint		  = 2;		// Free cut level.
			public static const kHeavyFreeCutLevel:uint   = 3;		// Larger log size free cut level
			public static const kMixedFreeCutLevel:uint   = 4;		// Mixed log size free cut level
			
			// Collection names according to level played.
			public static const kCollectionDirCutPieces:String	= "CutPieces - Directional Cut Level";
			public static const kCollectionFreeCutPieces:String	= "CutPieces - Free Cut Level";
			public static const kCollectionDirCutGames:String	= "Directional Cut";
			public static const kCollectionFreeCutGames:String	= "Free Cut";
			
			// Strings indicating accptance/rejection status of cut pieces.
			public static const kAcceptString:String		= "Yes";
			public static const kRejectShortString:String	= "No-Short";
			public static const kRejectLongString:String	= "No-Long";
			
			// Minimum accepted cut length in pixels.
			public static const kMinCutLength:Number	= kReferenceLength * (1.0 - (kPercentAllowance / 100));	
			// Maximum accepted cut length in pixels.
			public static const kMaxCutLength:Number	= kReferenceLength * (1.0 + (kPercentAllowance / 100));	
			
			// Create a timer to update the fuel level display and game duration.
			private var mFuelTimer:Timer = new Timer(kUpdateInterval, kTotalUpdates);
			
			// The down arrow.
			private var mArrowSprite:EnhancedSprite = new EnhancedSprite();
			private var mCutRightSprite:EnhancedSprite = new EnhancedSprite();
			private var mCutLeftSprite:EnhancedSprite = new EnhancedSprite();
			
			private var mFirstGame:Boolean			= true;	// Used for initial operations.
			private var mGameLevel:uint				= 3;	// Current game level. --init as 3 to force it to go through init loops in game select
			private var mPrevLevel:uint				= 3;	// Used to track level changes.
			private var mDirCutCollectionCreated:Boolean = false;	// Collection created on first play at each level.
			private var mFreeCutCollectionCreated:Boolean = false;	// Collection created on first play at each level.
			private var mLevelWindow:GameLevelWindow;		// The modal window for choosing a game level.
			private var mLogsPerGame:uint			= 4;	// Number of logs being used in each game.
			private var mFuelUsed:Number			= 0;	// Stores how many units of fuel have been used.
			private var mChainsawCursorID:Number	= 0;	// Holds a cursor ID.
			private var mGameNumber:uint			= 0;	// Keeps track of games since app launch. Practice level ignored.
			private var mCurrentLog:uint			= 1;	// Current log being cut. 1 based.
			private var mLastLog:uint				= 0;	// Number of log at most recent cut. 1 based. 0 before cuts.
			private var mLastCutX:Number			= 0;	// X location of most recent cut.
			private var mLeftToRight:Boolean		= true;	// Current cutting direction of log.
			private var mPiecesAccepted:uint		= 0;	// Number of cut pieces accepted.
			private var mPiecesRejected:uint		= 0;	// Number of cut pieces rejected.
			private var mPiecesShort:uint			= 0;	// Number of cut pieces rejected as short.
			private var mPiecesLong:uint			= 0;	// Number of cut pieces rejected as long.
			private var mPiecesRemnant:uint			= 0;	// Number of cut pieces rejected as remnants.
			private var mPlayersName:String			= "Player"; // Stores player's name.
			
			private var currentCutStartPoint:Number; // Holds the starting position for each cut.
			
			// These arrays store the details of individual logs for access by all who need to know.
			private var mLogDetails1:Array;
			private var mLogDetails2:Array;
			private var mLogDetails3:Array;
			private var mLogDetails4:Array;
			
			// Stores array of logs/logtops used in game.
			private var mLogArray:Array;
			
			// Holds piece number beginning at 1 for each cut piece since start of application.
			// Transmitted to TinkerPlots/Fathom. Practice level ignored.
			private var mPieceNumber:uint			= 0;	
			
			// Holds value of piece count as of previous game. Used in free cut levels to calculate
			// piece numbers in cut order rather than location on log.
			private var mPrevPieceNumber:uint		= 0;
			
			// Holds cut number beginning at 1 for cuts made in free cut levels.
			private var mCutNumber:uint				= 0;
			
			// An array that keeps track of the cuts
			private var mCutsArray:Array = new Array();
			
			// Embed the cursor symbol.
			// From http://www.rw-designer.com/cursor-download.php?id=2222 on 12/11/2010
			// Converted from .ani format to .png.
			[Embed(source="../chainsaw_assets/Chainsaw Cursor 2.png")]
			private var mChainsawCursor:Class;
			
			// Embed the reference length image file.
			[Embed(source="../chainsaw_assets/Reference Length 75 Pixels.png")]
			[Bindable]
			private var mLengthImage:Class;
			
			// Embed tape measure image
			[Embed(source="../chainsaw_assets/tape_measure.png")]
			[Bindable]
			private var mTapeMeasureImage:Class;
			
			// Embed the down arrow image file.
			[Embed(source="../chainsaw_assets/Down Arrow Small.png")]
			[Bindable]
			private var mDownArrowImage:Class;
			
			[Embed(source="../chainsaw_assets/Cut From Here Right.png")]
			[Bindable]
			private var mCutRightArrow:Class;
			
			[Embed(source="../chainsaw_assets/Cut From Here Left.png")]
			[Bindable]
			private var mCutLeftArrow:Class;

			
			// Embed volume icon
			[Embed(source="../chainsaw_assets/Volume.png")]
			[Bindable]
			private var mVolumeIcon:Class;
			
			[Embed(source="../chainsaw_assets/Volume_half.png")]
			[Bindable]
			private var mHalfVolumeIcon:Class;
			
			[Embed(source="../chainsaw_assets/Volume_off.png")]
			[Bindable]
			private var mLowVolumeIcon:Class;
			
			/*
			Actual sound files replaced with a 1-second dummy file to allow project to compile without removing sound-related code
			*/
//			[Embed("../src/chainsaw_assets/Chainsaw Sound Longer.mp3")]
			[Embed("../src/chainsaw_assets/dummy.mp3")]
			private var ChainsawSoundMP3:Class;
			private var mChainsawSound:Sound = new ChainsawSoundMP3() as Sound;
			
//			[Embed("../src/chainsaw_assets/Chainsaw Engine Stops no Fade In.mp3")]
			[Embed("../src/chainsaw_assets/dummy.mp3")]
			private var EngineStopSoundMP3:Class;
			private var mEngineStopsSound:Sound = new EngineStopSoundMP3() as Sound;
			
			// startUp() is called when the creation of this class is complete
			// and sets up necessary parameters for game initiation.
			private	function startUp():void
			{
				
				// Arrays store individual cuts on each log for use in free cut levels.		
				mLogDetails1 = new Array(dynamicLog1, null, new Array());
				mLogDetails2 = new Array(dynamicLog2, null, new Array());
				mLogDetails3 = new Array(dynamicLog3, null, new Array());
				mLogDetails4 = new Array(dynamicLog4, null, new Array());
				// Stores array of logs/logtops used in game.
				// Create new log array and add log/logtop to array.
				mLogArray = new Array(mLogDetails1, mLogDetails2, mLogDetails3, mLogDetails4);
				
				// Load and draw the cut location arrow.
				mArrowSprite.loadImage(mDownArrowImage);
				mArrowSprite.visible = false;
				mLogYardContainer.addElement(mArrowSprite);
				
				mCutRightSprite.loadImage(mCutRightArrow);
				mCutRightSprite.visible = false;
				mLogYardContainer.addElement(mCutRightSprite);
				
				mCutLeftSprite.loadImage(mCutLeftArrow);
				mCutLeftSprite.visible = false;
				mLogYardContainer.addElement(mCutLeftSprite);
				
				// Randomize log array.
				randomizeLogSizePosition();
				
				// add particle emitter to display
				uic.addChild(sawdustParticles);
				uic.mouseEnabled = false; //not quashing the mouse events from UIC was causing mouse events when its children particles were thrown in front of the mouse
				uic.mouseChildren = false;
				sawdustParticles.xOffset = 10;
				sawdustParticles.yOffset = 10;
				sawdustParticles.pColor = 0xD4B077;
				sawdustParticles.yFloor = 410;
				
				mLevelWindow = new GameLevelWindow();
//				levelSelected(kPracticeLevel);
				levelSelected(kFreeCutLevel); //Start in free cut mode
			}
			
			// clearGame() resets the game according to the current level and clears remnants of
			// the previous game, if any.
			private function clearGame(iNewGameLevel:uint):void
			{
				// Move direction arrow sprites to first log				
				resetArrowSprites();
				
				// remove all Status Labels from the holder and hide the holder
				mStatusLabelHolder.visible = false;
				mStatusLabelHolder.removeAllElements();
				
				// Enable/show log cutting edge. Clear all cuts in array.
				for (var i:Number = 0; i < mLogsPerGame; ++i)
				{
					if (iNewGameLevel >= kFreeCutLevel)
					{
						// Clear cut lists on log.
						while (mLogArray[i][2].length > 0)
							mLogArray[i][2].pop();
					}	
				}
				
				flashGasTank['resetDrop'](); // Set fuel height back to top of fuel container.
				mFuelUsed = 0;		// Initialize the fuel used to zero.
			}
			
			// chooseGameLevel() listens for clicks on the level dialog's level buttons.
			private function chooseGameLevel():void 
			{
				var isModal:Boolean = true;
				PopUpManager.addPopUp(mLevelWindow, this, isModal); 
				
				PopUpManager.centerPopUp(mLevelWindow);		// Center the window.
				mLevelWindow.closeButton.visible = false;	// Hide the close button.
				
				mLevelWindow["mPracticeLevelButton"].addEventListener("click", practiceLevel);
				mLevelWindow["mDirectionalCutButton"].addEventListener("click", directionalCutLevel);
				mLevelWindow["mFreeCutButton"].addEventListener("click", freeCutLevel);
				mLevelWindow["mHeavyFreeCutButton"].addEventListener("click", heavyFreeCutLevel);
				mLevelWindow["mMixedFreeCutButton"].addEventListener("click", mixedFreeCutLevel);
			}
			
			// practiceLevel() sets the current game level to practice.
			private function practiceLevel(iEvent:Event):void 
			{
				levelSelected(kPracticeLevel);
			}
			
			// directionalCutLevel() sets the current game level to directional cut.
			private function directionalCutLevel(iEvent:Event):void 
			{
				levelSelected(kDirectionalCutLevel);
			}
			
			// freeCutLevel() sets the current game level to free cut.
			private function freeCutLevel(iEvent:Event):void 
			{
				levelSelected(kFreeCutLevel);
			}
			private function heavyFreeCutLevel(iEvent:Event):void
			{
				levelSelected(kHeavyFreeCutLevel);
			}
			private function mixedFreeCutLevel(iEvent:Event):void
			{
				levelSelected(kMixedFreeCutLevel);
			}
			
			//level select redirected from button calls with level number - sets up the play field for each level
			private function levelSelected(levelNum:int):void
			{
				mPrevLevel = mGameLevel; // Track game level change.
				mGameLevel = levelNum; // Set game level
				PopUpManager.removePopUp(mLevelWindow); // Close the modal window
				
				// Only reset if user selects different level (Otherwise it will be reset when they click start)
				if(mPrevLevel != mGameLevel) 
				{
					if(mPrevLevel >= kHeavyFreeCutLevel){
						dynamicLog1.resizeLogFront(35,12);
						dynamicLog1.setLogWidthLabel("thin");
						dynamicLog2.resizeLogFront(35,12);
						dynamicLog2.setLogWidthLabel("thin");
						dynamicLog3.resizeLogFront(35,12);
						dynamicLog3.setLogWidthLabel("thin");
						dynamicLog4.resizeLogFront(35,12);
						dynamicLog4.setLogWidthLabel("thin");
					}
					randomizeLogSizePosition(); // Randomize logs
					
					if (levelNum >= kFreeCutLevel) // If Free Cut level was selected
					{
						if(levelNum == kHeavyFreeCutLevel){
							dynamicLog1.resizeLogFront(50,15);
							dynamicLog1.setLogWidthLabel("thick");
							dynamicLog2.resizeLogFront(50,15);
							dynamicLog2.setLogWidthLabel("thick");
							dynamicLog3.resizeLogFront(50,15);
							dynamicLog3.setLogWidthLabel("thick");
							dynamicLog4.resizeLogFront(50,15);
							dynamicLog4.setLogWidthLabel("thick");
							mLevelLabel.text = "HEAVY FREE CUT LEVEL";
						}else if(levelNum == kMixedFreeCutLevel){
							dynamicLog1.resizeLogFront(50,15);
							dynamicLog1.setLogWidthLabel("thick");
							dynamicLog2.resizeLogFront(35,15);
							dynamicLog2.setLogWidthLabel("thin");
							dynamicLog3.resizeLogFront(50,15);
							dynamicLog3.setLogWidthLabel("thick");
							dynamicLog4.resizeLogFront(35,15);
							dynamicLog4.setLogWidthLabel("thin");
							mLevelLabel.text = "MIXED FREE CUT LEVEL";
						}else{
							mLevelLabel.text = "FREE CUT LEVEL";
						}
						clearGame(kFreeCutLevel); 
						dynamicLog1['init'](0,dynamicLog2); // send cut direction and link to next log
						dynamicLog2['init'](0,dynamicLog3); // cut direction 1=LtoR, -1=RtoL, 0 = free
						dynamicLog3['init'](0,dynamicLog4);
						dynamicLog4['init'](0,null);
						
						mArrowSprite.visible		= false; // Hide cut location arrow.
						mCutRightSprite.visible		= false; 
						mCutLeftSprite.visible		= false; 
						
						if (!mFreeCutCollectionCreated) //create collection for free cut if not already created
						{
							createCollectionMod(kCollectionFreeCutPieces, kCollectionFreeCutGames);
							mFreeCutCollectionCreated = true;
						}
					}else // If Practice or Directional Cut level was selected
					{
						clearGame(0);
						dynamicLog1['init'](1,dynamicLog2); //send cut direction and link to next log
						dynamicLog2['init'](-1,dynamicLog3); // cut direction 1=LtoR, -1=RtoL, 0 = free
						dynamicLog3['init'](1,dynamicLog4);
						dynamicLog4['init'](-1,null);

						mArrowSprite.visible		= false; // Show cut location arrow.
						mCutRightSprite.visible		= true;
						mCutLeftSprite.visible		= false;
						
						if (!mDirCutCollectionCreated) //create collection for directional cut if not already created
						{
							createCollectionMod(kCollectionDirCutPieces, kCollectionDirCutGames);
							mDirCutCollectionCreated = true;
						}
						
						if (levelNum == kDirectionalCutLevel)	mLevelLabel.text = "DIRECTIONAL CUT LEVEL";
						if (levelNum == kPracticeLevel)			mLevelLabel.text = "PRACTICE LEVEL";
					}
				}
			}
			
			// randomizeLogSizePosition() randomly resorts the logs in the log array.
			protected function randomizeLogSizePosition():void
			{
				dynamicLog1.x = Math.random()*120+40;
				dynamicLog1.y = 38;
				dynamicLog1['drawNewLog'](pickLogLength());
				
				dynamicLog2.x = Math.random()*120+40;
				dynamicLog2.y = 120;//127
				dynamicLog2['drawNewLog'](pickLogLength());
				
				dynamicLog3.x = Math.random()*120+40;
				dynamicLog3.y = 202;//216
				dynamicLog3['drawNewLog'](pickLogLength());
				
				dynamicLog4.x = Math.random()*120+40;
				dynamicLog4.y = 284;//305
				dynamicLog4['drawNewLog'](pickLogLength());
				
				// Move direction arrow sprites to first log
				resetArrowSprites();

				mArrowSprite.x = mLogArray[0][0].x - mArrowSprite.getWidth() + 5;	// Start with arrow pointing at left edge of first log.
				mArrowSprite.y = mLogArray[0][0].y - (mArrowSprite.getHeight()+2);	// Start at top edge of first log.
			}
			
			private function resetArrowSprites():void
			{
				// Move direction arrow sprites to first log				
				mCutRightSprite.x = mLogArray[0][0].x - 58;
				mCutRightSprite.y = mLogArray[0][0].y - 30;
				mCutLeftSprite.x = mLogArray[0][0].x + mLogArray[0][0].width;
				mCutLeftSprite.y = mLogArray[0][0].y - 30;
			}
			
			/**
			 * Helper function for randomizeLogSizePosition() that returns a length as an int that
			 * is long enough for 4 or 5 logs with a little extra padding (1/2 to 6/7 of a log length).
			 * 
			 * @return length
			 * @author Ryan
			 */
			private function pickLogLength():int
			{
				var length:int;
				length = kReferenceLength*4;									// The base length (4 pieces long)
				length+= Math.round(Math.random())*kReferenceLength;			// Randomly add or don't add a 5th piece to the length 
				length+= Math.ceil(Math.random()*(kReferenceLength*0.36)+0.5);	// Finally add 1/2 to 6/7 of a piece to the log as padding
				return length;	// Return the length
			}
			
			//called by directionalCutLevel() and freeCutLevel() to initially create TinkerPlot/DG collection spaces
			private function createCollectionMod(collection1:String, collection2:String):void
			{
				ScriptInterface.NewCollectionWithAttributes(
					"Cuts",
					[
						"PieceNum",			// Piece number starting with 1 since launch of application.
						"Player",			// Name of the player.
						"GameNum",			// Game number starting with 1 since launch of application.
						"Length",			// Length of cut piece.
						"Thickness",		// Thin or thick depending on game type
						"Accepted",			// True if cut piece is within accepted range of cut length.
						"EndPiece",			// Yes if this piece is an end piece.
						"LogNum",			// Number of log from which piece was cut.
						"FuelLeftAmount",	// Raw amount of fuel left at the time of piece creation.
						"FuelLeftPercent"	// Percent of fuel left at the time of piece creation.
					]
				);
				
				// Create collection for each game.
				ScriptInterface.NewCollectionWithAttributes(
					"Games",
					[
						"GameNumber",		// Game number starting with 1 since launch of application.
						"GameType",			// Direction Cut or Free Cut
						"Player",			// Name of the player.
						"PiecesAccepted",	// Number of pieces accepted.
						"PiecesRejected",	// Number of pieces rejected.
						"Pieces_Short",		// Number of pieces rejected as short.
						"Pieces_Long",		// Number of pieces rejected as long.
						"Pieces_Remnant",	// Number of pieces rejected as remnant.
						"FuelLeftAmount",	// Raw amount of fuel left.
						"FuelLeftPercent"	// Percent of fuel left.
					]
				);
			}
			
			// recordPieceStatus() evaluates the piece's acceptance status and records the outcome
			// by setting a visual marker on each log and also transmitting the info to 
			// Fathom/TinkerPlots.
			protected function recordPieceStatus(iLength:Number,		// Piece length
												 iLogNumber:int, 		// Number of log ( 1 is at top).
												 iIsEndPiece:Boolean, 	// True if end piece.
												 iLeftToRight:Boolean,	// True if cutting left to right.
												 iIsNewLog:Boolean,		// True if measuring on new log for first time.
												 iFuelUsed:Number,		// Raw fuel used at the time of piece creation.
												 iPrevXCut:Number = 0,	// Cut before this cut or game end.
												 iCutX:Number = 0,		// X cut location on log. 0 if end piece.
												 iPieceNumber:uint = 0	// Piece number. If not 0, transmit this number instead of mPieceNumber.
			):void
			{
				var currentLog:MovieClip = mLogArray[iLogNumber-1][0] as MovieClip; // The current log
				var log_length:Number = currentLog['LogLength']; // get the length of the current log
				
				// Not cutting, so don't specify a cut location.
				if (iIsEndPiece) iCutX = 0;
				
				// Create "X" or "√" for piece to indicate rejected or accepted. "O" for remnants.
				var statusLabel:Label	= new Label();
				statusLabel.width		= 14;			// Setting manually, as measureText() fails with Spark Label.
				statusLabel.height		= 14;
				statusLabel.setStyle("fontWeight", "bold");
				statusLabel.setStyle("fontSize", "16");
				statusLabel.setStyle("antiAliasType", "normal");
				statusLabel.setStyle("justificationStyle", "auto");
				
				// Accept cut piece if it falls within accepted range.
				var accepted:Boolean = (iLength >= kMinCutLength) && (iLength <= kMaxCutLength);
				var remnant:Boolean;
				var acceptString:String;
				
				// Check if a piece is a remnant if it is not accepted
				if(!accepted)
				{
					remnant = false; // Initialize to false
					
					if(iIsEndPiece)
					{
						// if there is not enough room for two cuts at the (but more than one)
						if(iLeftToRight && (log_length - iPrevXCut) < kReferenceLength*2) //left to right cut
						{
							remnant = true;
						}
						else if(iPrevXCut < kReferenceLength*2) //right to left cut
						{
							remnant = true;
						}
					}
					
					if(iLength <= kReferenceLength/2) // a piece less than or equal to half the reference length
					{
						remnant = true;
					}
					if(iLength >= kReferenceLength+(kReferenceLength/2)) // a piece over 1.5 times the reference length
					{
						remnant = true;
					}
				}
				
				// Keep track of how many cut pieces are accepted / rejected and set status label text.
				if (accepted){
					if (mGameLevel != kPracticeLevel)
						++mPieceNumber;
					++mPiecesAccepted;
					statusLabel.text	= "√";					// Check mark = OK.
					statusLabel.setStyle("color", "0x00FF00");	// Green = OK.
					acceptString = kAcceptString;
				}else if (remnant){
					if (mGameLevel != kPracticeLevel)  ++mPieceNumber;	
					statusLabel.text = "O";
					statusLabel.setStyle("color", "0xFFFF00"); // Yellow
					acceptString = "Remnant";
					++mPiecesRemnant;
				}else{
					if (mGameLevel != kPracticeLevel) ++mPieceNumber;
					++mPiecesRejected;
					statusLabel.text = "X";						// X = not OK.
					statusLabel.setStyle("color", "0xFF0000");	// Red = not OK.
					if(iLength < kMinCutLength){
						acceptString = kRejectShortString;
						++mPiecesShort;
					}else{
						acceptString = kRejectLongString;
						++mPiecesLong;
					}
				}
				
				// Set y location of status label for cut piece.
				statusLabel.y = (currentLog.height / 2) - (statusLabel.height / 2) + currentLog.y;
				// Set x location of status label for cut piece.
				if (iLeftToRight>0){
					// End piece or cutting along same log as at the last cut.
					if (iIsEndPiece || (!iIsEndPiece && !iIsNewLog))
						statusLabel.x = iPrevXCut + (iLength / 2) - (statusLabel.width / 2)+currentLog.x;
						// Cutting on new log.
					else statusLabel.x = (iLength / 2) - (statusLabel.width / 2)+currentLog.x;
				}
				else statusLabel.x = iCutX + (iLength / 2) - (statusLabel.width / 2)+currentLog.x;
				
				//add statusLabel element to holder to be shown later
				mStatusLabelHolder.addElement(statusLabel);
				
				if (mGameLevel != kPracticeLevel){	
					var lengthTwoDecimals:String	= (iLength * kConvertToInches).toFixed(2);
					var fuelLeftFraction:Number		= 1 - (iFuelUsed / kTotalUpdates);
					var fuelLeftAmount:Number		= fuelLeftFraction * kFuelCapacity;
					var fuelLeftPercent:Number		= fuelLeftFraction * 100;
					var pieceNumber:uint 			= iPieceNumber == 0 ? mPieceNumber : iPieceNumber;
					var collectionName:String;
					var isEnd:String = iIsEndPiece ? "Yes" : "No";
					// Send info on cut pieces to TinkerPlots/Fathom.
					if (mGameLevel == kDirectionalCutLevel)
						collectionName = kCollectionDirCutPieces;
						//TODO replace these AddCaseToCollectionWithValues() calls with a single one
					else
						collectionName = kCollectionFreeCutPieces;
					
					ScriptInterface.AddCaseToCollectionWithValues(
						//kCollectionDirCutPieces,  //**Tristan
						"Cuts",
						[
							pieceNumber,		// Piece number since application launch. Ignore practice level.
							mPlayersName,		// Name of the player.
							mGameNumber,		// Game number starting with 1 since launch of application.  Ignore practice level.
							lengthTwoDecimals,	// Piece length.
							currentLog.getLogWidthLabel(),	//log label "thin" or "thick"
							acceptString,		// Status of cut piece.
							isEnd,				// "Yes" if it is an end piece.
							iLogNumber,			// Number of log from which piece was cut.
							fuelLeftAmount,		// Raw fuel left at the time of piece creation.
							fuelLeftPercent		// Percent of fuel left at the time of piece creation.
						]	
					);
				}
			}
			
			// startGame() is called whenever the start button is pressed.
			protected function startGame():void
			{
				mLastLog			= 0;	// Reset last cut log counter.
				mCurrentLog			= 1;	// Reset log counter.
				mLastCutX			= 0;	// Reset X position of most recent cut.
				mPiecesAccepted		= 0;	// Reset number of cut pieces accepted.
				mPiecesRejected		= 0;	// Reset number of cut pieces rejected.
				mLeftToRight		= true;	// Begin cutting left to right.
				mCutNumber			= 0;	// Reset cut number.
				
				mChainsawSound.play(0,int.MAX_VALUE); // start the chainsaw sound
				
				// Randomize log array, but not for first game, as it's already random.
				if (!mFirstGame)
				{
					// Don't randomize if this was just done on level change.
					if (mPrevLevel == mGameLevel)
						randomizeLogSizePosition();
				}
				else mFirstGame = false;
				
				clearGame(mGameLevel); // Clear any remnants of last game and reset game.
				
				mChangeLevelButton.enabled	= false;
				mPlayerTextInput.enabled	= false;
				mChainsawCursorID			= CursorManager.setCursor(mChainsawCursor, CursorManagerPriority.HIGH);
				
				if (mGameLevel < kFreeCutLevel)
				{
					mCutRightSprite.visible = true; //display direction arrow
					mCutLeftSprite.visible = false;
				}
				
				// Use timer to update the fuel level display and game duration.
				if (mGameLevel != kPracticeLevel)
				{
					// Set game number since app launch when new game starts, not counting practice level).
					++mGameNumber;
					// Set up the fuel timer and visual gas tank
					mFuelTimer.addEventListener(TimerEvent.TIMER, timerListener);
					mFuelTimer.reset();	// Reset the timer to run until fuel runs out.
					mFuelTimer.start(); // Start the timer, now that all variables are set up.
					flashGasTank['initGasTank'](kTimeLimit * 24);
					flashGasTank['startDrop']();
				}
				dynamicLog1.enabled = true;
				if (mGameLevel >= kFreeCutLevel){
					dynamicLog2.enabled = true;
					dynamicLog3.enabled = true;
					dynamicLog4.enabled = true;
					mArrowSprite.visible = false;
				}
			}
			
			// endGame() performs all operations necessary when game is complete.
			protected function endGame():void
			{
				doEndGameStop();
				if (mGameLevel >= kFreeCutLevel){
					checkFreeCuts();
					determineCutStyle();
				}
					// Directional cut mode. Measure end piece if player has already started cutting current log and we run out of fuel
				else if (mCurrentLog == mLastLog && mFuelUsed == kFuelCapacity)
				{
					// Calculate distance from end of log in the direction player was cutting.
					// mCurrentLog begins at 1. Array index begins at 0.
					var woodRemaining:Number	= mLeftToRight? mLogArray[mCurrentLog-1][0].width - mLastCutX -10 : mLastCutX;
					var isEndPiece:Boolean		= true;
					
					// Evaluate the piece's acceptance status and record the outcome by setting a 
					// visual marker on each log and also transmit the info to Fathom/TinkerPlots.
					recordPieceStatus(	
						woodRemaining, 			// Piece length
						mCurrentLog, 			// Number of log ( 1 is at top).
						isEndPiece, 			// True if end piece.
						mLeftToRight, 			// True if cutting left to right.
						mCurrentLog != mLastLog,// True if measuring on new log for first time.
						mFuelUsed,				// Raw fuel used at the time of piece creation.
						mLastCutX);				// X cut location on log. 0 if end piece.
				}
				
				var fuelLeftFraction:Number	= 1 - (mFuelUsed / kTotalUpdates);
				var fuelLeftAmount:Number	= fuelLeftFraction * kFuelCapacity;
				var fuelLeftPercent:Number	= fuelLeftFraction * 100;
				
				//send game information to TinkerPlots/Fathom
				if (mGameLevel != kPracticeLevel)
				{
					var gameCollectionName:String	
					= (mGameLevel >= kFreeCutLevel) ? kCollectionFreeCutGames : kCollectionDirCutGames;
					
					// Send info on games to TinkerPlots/Fathom.
					ScriptInterface.AddCaseToCollectionWithValues(
						//gameCollectionName, //**Tristan
						"Games",
						[
							mGameNumber,		// Game number starting with 1 since launch of application.
							gameCollectionName,	// Game Type
							mPlayersName,		// Name of the player.
							mPiecesAccepted,	// Number of pieces accepted.
							mPiecesRejected,	// Number of pieces rejected.
							mPiecesShort,		// Number of pieces rejected as short.
							mPiecesLong,		// Number of pieces rejected as long.
							mPiecesRemnant,		// Number of pieces rejected as remnant.
							fuelLeftAmount,		// Raw amount of fuel left.
							fuelLeftPercent		// Percent of fuel left.
						]	
					);
				}
				
				mResultsOverlay.visible		= true;								// Display the results Overlay
				mAcceptedPiecesValue.text	= mPiecesAccepted.toString();		// Update the number of accepted pieces.
				
				mFuelLeftValue.text	= fuelLeftAmount.toString() +" ("+ fuelLeftPercent.toFixed();		// Update the percentage of fuel left.
				mFuelLeftValue.text = mFuelLeftValue.text.replace(/\.\d*/,"") + "%)"; // remove the decimal point and trailing digits, then append '%'
				
				mPrevLevel 			= mGameLevel;	// Track game level change.
				mPrevPieceNumber	= mPieceNumber;	// Track piece number at the end of the game.
			}
			
			// sub-function of endGame(), stops all game functions and enables regular UI items
			private function doEndGameStop():void{
				dynamicLog1.enabled = false;//disable all logs from being cut
				dynamicLog2.enabled = false;
				dynamicLog3.enabled = false;
				dynamicLog4.enabled = false;
				
				mStatusLabelHolder.visible=true;//show all status labels
				
				mArrowSprite.visible = false; //hide cut place arrow if it is shown
				mCutRightSprite.visible = false;
				mCutLeftSprite.visible = false;
				
				if (mGameLevel != kPracticeLevel)
				{
					mFuelTimer.stop();													// Stop fuel timer.
					mFuelTimer.removeEventListener(TimerEvent.TIMER, timerListener);	// Stop listening.
					flashGasTank['pauseDrop']();	//stop gas tank animation
				}
				
				CursorManager.removeCursor(mChainsawCursorID);	// Remove chainsaw cursor.
				SoundMixer.stopAll();							// Stop all currently playing sounds
				mEngineStopsSound.play();						// Play chainsaw engine stopping sound.
				
				mStartStopButton.label			= "Start";
				
				mChangeLevelButton.enabled		= true;
				mPlayerTextInput.enabled		= true;
			}
			
			// sub-fucntion of endGame() to create and check pieces from free cut level
			private function checkFreeCuts():void{
				// Stores individual pieces to be sorted by cut order in a second pass.
				var pieceStatusArray:Array = new Array;
				
				// For each log
				for (var ii:Number = 0; ii < mLogsPerGame; ++ii) 
				{
					// Sort log's cutlist left to right. Must specify NUMERIC or sort will be by string.
					mLogArray[ii][2].sortOn("mCutX", Array.NUMERIC);
					
					var prevCut:Number	= 0;	// Start at the left edge of the log.
					
					// For each cut position
					for (var j:Number = 0; j < mLogArray[ii][2].length; ++j)
					{
						var length:Number		= 0;		// Length of piece.
						var isEnd:Boolean		= false;	// No end pieces in free cut level.
						var leftToRight:Boolean	= true;		// Measuring left to right.
						
						// Piece number for free cut is in cut order, not location on log.
						//	var pieceNumber:uint	= mLogArray[ii][2][j].mCutNumber + pieceNumberBase;
						
						// Calculate the piece length and transmit to TinkerPlots/Fathom.
						length = mLogArray[ii][2][j].mCutX - prevCut;
						
						var pieceStatus:PieceStatus = 
							new PieceStatus(
								length,							// Piece length.
								ii + 1, 						// Number of log (1 is at top).
								isEnd, 							// True if end piece.
								leftToRight,					// True if cutting left to right.
								prevCut == 0,					// True if measuring on new log for first time.
								mLogArray[ii][2][j].mFuelUsed,	// Raw fuel left at the time of piece creation.
								prevCut,						// Cut before this cut or game end.
								mLogArray[ii][2][j].mCutX,		// X cut location on log. 0 if end piece.
								mLogArray[ii][2][j].mCutNumber	// Cut number. 
							);
						
						pieceStatusArray.push(pieceStatus);
						prevCut = mLogArray[ii][2][j].mCutX;	// Save previous cut position.
						
						// Calculate the rightmost piece length, if it's the final cut.
						if (j == (mLogArray[ii][2].length - 1))
						{
							// Used to increment next cut numbers and provide sequential pieece numbers.
							++pieceNumberBase;
							var lastLength:Number;
							lastLength = mLogArray[ii][0].width - mLogArray[ii][2][j].mCutX - 10; //subtract 10 to account for curve on log face
							var endPieceStatus:PieceStatus = 
								new PieceStatus(
									lastLength,						// Piece length.
									ii + 1, 						// Number of log (1 is at top).
									isEnd, 							// True if end piece.
									leftToRight,					// True if cutting left to right.
									false,							// True if measuring on new log for first time.
									mLogArray[ii][2][j].mFuelUsed,	// Raw fuel left at the time of piece creation.
									prevCut,						// Cut before this cut or game end.
									0,								// X cut location on log. 0 if end piece.
									mLogArray[ii][2][j].mCutNumber	// Cut number.  
								);
							pieceStatusArray.push(endPieceStatus);
						}
					}
				}
				
				// In second pass, sort pieces by cut number and use these cut numbers to 
				// calculate piece numbers, taking end pieces into account.
				pieceStatusArray.sortOn("mCutNumber", Array.NUMERIC);
				
				// Used in calculating piece numbers.
				var pieceNumberBase:uint	= mPrevPieceNumber;
				var prevCutNumber:uint		= 0;
				
				// For each cut position
				for (var k:Number = 0; k < pieceStatusArray.length; ++k)
				{
					if (pieceStatusArray[k].mCutNumber == prevCutNumber)
						++pieceNumberBase;
					
					// Transmit to TinkerPlots/Fathom.
					recordPieceStatus(	
						pieceStatusArray[k].mLength,			
						pieceStatusArray[k].mLogNumber, 		
						pieceStatusArray[k].mIsEndPiece, 	
						pieceStatusArray[k].mLeftToRight,	
						pieceStatusArray[k].mIsNewLog,		
						pieceStatusArray[k].mFuelUsed,		
						pieceStatusArray[k].mPrevXCut,	
						pieceStatusArray[k].mCutX,		
						pieceStatusArray[k].mCutNumber + pieceNumberBase
					);
					
					prevCutNumber = pieceStatusArray[k].mCutNumber; // Track previous cut number.
				}
			}
			
			/**
			 * Guesses the cut style of the player using data stored in CutProperties objects,
			 * created after each cut. Only matters for Free Cut levels.
			 * @author Ryan
			 */
			private function determineCutStyle():void
			{
				var style:String = "Other";
				
				if(mCutsArray.length <= 1) return;
				
				//First: check to see if the first two cuts are on the same log
				if(mCutsArray[0].log == mCutsArray[1].log){
					//If they are, do this
					//possible styles: directional
					if(CutProperties.checkDirectional(mCutsArray)){
						style = "Directional";
						trace("Passed: Directional");
					}

				} else {
					//If they are not, do this
					//possible styles: vertical
					if(CutProperties.checkVertical(mCutsArray)) style = "Vertical";
				}
				
				//If the style does not match any known styles, classify it as 'Other'
				
				style += CutProperties.findCutDirectionStyle(mCutsArray);
				
				
				//Important - we need to clear out the array each time
				while(mCutsArray.length>0){
					mCutsArray.pop();
				}
				
				mCutStyleValue.text = style; //finally set the text to display the determined cut style
			}
			
			// timerListener() is called to update the fuel level display and game duration.
			// now just updates the mFuelUsed
			protected function timerListener(iEvent:TimerEvent):void
			{
				// Increment the units of fuel used at the start, as this amount was used since 
				// the start or previous timer interval.
				++mFuelUsed;
				// If there is still fuel left, provide updates and effects used during game play.
				if (mFuelUsed >= kTotalUpdates){
					// Fuel has been consumed and game is over.
					endGame();					
				}				
			}
			
			// cutLogInOrder() performs all cutting operations when the passed in log is cut at 
			// the x position being passed in. The x position is in the coordinate system of the log being cut.	
			protected function cutLogInOrderMod(iLog:MovieClip,
												iLocalX:Number,
												iNextLog:MovieClip = null,
												iTopToBottom:Boolean = true):void
			{
				// Don't cut if chainsaw is not running and we're not in practice mode.
				if (mGameLevel != kPracticeLevel && !mFuelTimer.running)return;
				
				var newArrowXPosition:Number = iLog.x + iLocalX - (0.75*mArrowSprite.getWidth());
				
				//get info from the log we are cutting
				iNextLog = iLog['getNextLog']();
				var iLeftToRight:int = iLog['getCutDirection']();
				
				// Only cut in specified direction.
				if ((iLeftToRight>0 && mArrowSprite.x < newArrowXPosition) || 
					(iLeftToRight<0 && mArrowSprite.x > newArrowXPosition))
				{					
					// Calculate distance from end of log in the direction player is cutting.
					var woodRemaining:Number	= iLeftToRight>0? iLog.width - iLocalX -10 : iLocalX;
					
					// If player has wood to cut, the intended cut is not an end piece.
					var isEndPiece:Boolean		= false; 
					
					//Move arrow to cut
					mArrowSprite.x = newArrowXPosition;	// Move arrow to location just selected.
					
					// If there is not enough wood left to do another acceptable cut on this 
					// log or the end piece is within the acceptable length range AND if there
					// remains another log to cut, move the arrow cursor to the next log and 
					// prepare to cut this next log.
					if	(woodRemaining <= kMaxCutLength)
					{	
						isEndPiece			= true;	// Remainder of log counts as an end piece.
						if(iNextLog){
							iLog.enabled		= false;// Stop further cuts on this log.
							iNextLog.enabled	= true;	// Enable cuts on this log.
							
							mArrowSprite.y = iNextLog.y - mArrowSprite.getHeight() - 3;	// Start at top edge of next log.
							mArrowSprite.x = iNextLog.x - mArrowSprite.getWidth() + 3;	// Start with arrow pointing at left edge of next log.
//							mArrowSprite.visible = false;
							if (iNextLog['getCutDirection']()<0){
								mArrowSprite.x = iNextLog.width+iNextLog.x - (mArrowSprite.getWidth()) - 5;	// Move to right end of log if just cut left to right.
							}
							
							mArrowSprite.visible = false;
							
							// Move arrows to next log.
							mCutRightSprite.x	= iNextLog.x - 58;
							mCutRightSprite.y	= iNextLog.y - 30;
							mCutLeftSprite.x	= iNextLog.x + iNextLog.width - 20;
							mCutLeftSprite.y	= iNextLog.y - 30;
							
							//make the appropriate cut direction arrow display
							var b:Boolean = iLeftToRight<0;
							mCutRightSprite.visible = b ? true : false;
							mCutLeftSprite.visible = b ? false : true;
							
							++mCurrentLog; // Increment the current log counter.
						}
					}
					else
					{
						mArrowSprite.visible	= true;
						mCutRightSprite.visible	= false;
						mCutLeftSprite.visible	= false;
					}
					
					var pieceLength:Number	= 0; // Length of piece player has just cut (in pixels).
					if (iLog['getLogNum']() == mLastLog)	// Cutting along same log as at the last cut.
						pieceLength = Math.abs(iLocalX - mLastCutX);
					else
					{
						if (iLeftToRight>0)
							pieceLength = iLocalX;				// First cut from left edge of log.
						else
							pieceLength = iLog.width - iLocalX - 10;	// First cut from right edge of log.
					}
					// Evaluate the piece's acceptance status and record the outcome by setting a 
					// visual marker on each log and also transmit the info to Fathom/TinkerPlots.
					var wasEndPiece:Boolean = false;	// This was not an end piece.
					recordPieceStatus(			
						pieceLength, 			// Piece length
						iLog['getLogNum'](), 			// Number of log ( 1 is at top).
						wasEndPiece, 			// True if end piece.
						iLeftToRight>0, 			// True if cutting left to right.
						(iLog['getLogNum']() != mLastLog),// True if measuring on new log for first time.
						mFuelUsed,				// Raw fuel used at the time of piece creation.
						mLastCutX, 				// Cut before this cut or game end.
						iLocalX);				// X cut location on log. 0 if end piece.
					
					mLastLog	= iLog['getLogNum']();	// Update cut log counter.
					mLastCutX	= iLocalX;		// Update X position of most recent cut.
					
					if (isEndPiece)
					{
						// Evaluate the piece's acceptance status and record the outcome by setting a 
						// visual marker on each log and also transmit the info to Fathom/TinkerPlots.
						recordPieceStatus(
							woodRemaining,	// Piece length
							iLog['getLogNum'](), 	// Number of log ( 1 is at top).
							isEndPiece, 	// True if end piece.
							iLeftToRight>0, 	// True if cutting left to right.
							false, 			// True if measuring on new log for first time.
							mFuelUsed,		// Raw fuel used at the time of piece creation.
							iLocalX);		// Cut before this cut or game end.
						
						//mLeftToRight = !mLeftToRight;	// Was end piece, so next log cuts in opposite direciton.
						
						if(iNextLog == null){			// If no other log to cut and this is an end piece, end game
							endGame();
						}else{
							mLastCutX = iNextLog.x + iNextLog.width;
						}
					}	
					
					
				}
			}
			
			// cutLogFreely() performs all cutting operations when the passed in log is cut at 
			// the x position being passed in. The x position is in the coordinate system
			// of the log being cut.
			protected function cutLogFreely(	iLog:MovieClip, 
												iLocalX:Number,
												iTopToBottom:Boolean = true
			):void
			{
				// Don't cut if chainsaw is not running and we're not in practice mode.
				var iLogNumber:int = iLog['getLogNum']();
				if (mGameLevel != kPracticeLevel)
				{
					if (!mFuelTimer.running)
						return;
				}
				
				++mCutNumber;	// Increment cut number.
				
				// Add X position of cut and fuel used to log's cut list.
				var cutAndFuelUsed:FuelUsedAtCut = new FuelUsedAtCut(iLocalX, mFuelUsed, mCutNumber);
				mLogArray[iLogNumber-1][2].push(cutAndFuelUsed);
				
				//store the cut properties
//				var currentLog:MovieClip = mLogArray[iLogNumber-1][0] as MovieClip;
//				var top_bottom:Boolean = currentLog['topToBottomCut']();
				var top_bottom:Boolean = iLog['isTopToBottomCut']();
				var prop:CutProperties = new CutProperties(mCutNumber, iLogNumber, iLocalX, top_bottom);
				mCutsArray.push(prop);
			}
			
			// onChangePlayerTextInput() is called whenever the text is changed in the mPlayerTextInput control.
			protected function onChangePlayerTextInput(iEvent:TextOperationEvent):void
			{
				mPlayersName = mPlayerTextInput.text;
			}
			
			// Player has pressed the Start/Stop button
			protected function onClickStartStopButton(event:MouseEvent):void
			{
				if(mStartStopButton.label == "Stop")
				{
					endGame();
					mStartStopButton.label = "Start";
				}
				else
				{
					startGame();
					mStartStopButton.label = "Stop";
				}
			}
			
			// onClickChangeLevelButton() allows the user to change the game level.
			protected function onClickChangeLevelButton(event:MouseEvent):void
			{
				chooseGameLevel();
			}
			
			//initialize Tristan's gas tank SWF
			protected function initGasTank():void{
				flashGasTank = mFuelIcon.content as MovieClip;
			}
			
			protected function initLog1():void{
				dynamicLog1 = mDynamicLog.content as MovieClip;
				dynamicLog1.enabled = false;
				dynamicLog1.mouseChildren = false;
				dynamicLog1['setLogNum'](1);
			}
			protected function initLog2():void{
				dynamicLog2 = mDynamicLog2.content as MovieClip;
				dynamicLog2.enabled = false;
				dynamicLog2.mouseChildren = false;
				dynamicLog2['setLogNum'](2);
			}
			protected function initLog3():void{
				dynamicLog3 = mDynamicLog3.content as MovieClip;
				dynamicLog3.enabled = false;
				dynamicLog3.mouseChildren = false;
				dynamicLog3['setLogNum'](3);
			}
			protected function initLog4():void{
				dynamicLog4 = mDynamicLog4.content as MovieClip;
				dynamicLog4.enabled = false;
				dynamicLog4.mouseChildren = false;
				dynamicLog4['setLogNum'](4);
			}
			
			//mouse up on currently enabled log, sends to the log's SWF for handling
			protected function logUp(e:MouseEvent):void{
				e.currentTarget.content['logUp'](e);
				//trace("logUp");
				sawdustParticles['stopParticleAnim']();
			}
			//mouse in event on currently enabled log
			protected function logIn(e:MouseEvent):void{
				if(e.buttonDown && e.currentTarget.content.enabled){
					
					//					sawdustParticles.x = e.stageX+10; //TODO REMOVE
					//					sawdustParticles.y = e.stageY+10;
					
					var offsetX:Number = e.localX - e.currentTarget.content.x;
					var offsetY:Number = e.localY - e.currentTarget.content.y;
					e.currentTarget.content['logInMod'](offsetX, offsetY);
					
					currentCutStartPoint = e.localX; //save where the cut was started
					
					//prevent showing particles if player is cutting wrong side of log
					if(e.currentTarget.content['canCutAt'](offsetX))
						sawdustParticles['startParticleAnim']();
				}
			}
			//mouse out event on enabled log
			protected function logOut(e:MouseEvent):void{
				sawdustParticles['stopParticleAnim']();
				var offsetX:Number = e.localX - e.currentTarget.content.x;
				var offsetY:Number = e.localY - e.currentTarget.content.y;
				if(e.currentTarget.content['logOutMod'](offsetX,offsetY)){
					if(mGameLevel >= kFreeCutLevel){
						cutLogFreely(e.currentTarget.content, e.currentTarget.content['StartCutPt'].x);
					}else{
						cutLogInOrderMod(e.currentTarget.content, e.currentTarget.content['StartCutPt'].x);
					}
				}
			}
			//mouse over event for updating cut as they go through the log
			protected function logMidLog(e:MouseEvent):void{				
				if (e.currentTarget.content.enabled){
					var offsetX:Number = e.localX - e.currentTarget.content.x;
					var offsetY:Number = e.localY - e.currentTarget.content.y;
					e.currentTarget.content['midLogMod'](offsetX,offsetY);
				}
				
				if(Math.abs(e.localX - currentCutStartPoint) > 20) logUp(e); //checks to see how far the mouse has moved since beginning to cut
			}
			
			protected function updateVolume(vol:Number):void
			{
				//cannot do: SoundMixer.soundTransform.volume = vol/100;
				var st:SoundTransform = SoundMixer.soundTransform;
				st.volume = vol/100; //changes range [0-100] (slider position) to [0-1] (volume level)
				SoundMixer.soundTransform = st;
				
				//adjust the volume level icon
				if(vol < 33){
					mVolumeImage.source = mLowVolumeIcon;
				} else if(vol > 66) {
					mVolumeImage.source = mVolumeIcon;
				} else {
					mVolumeImage.source = mHalfVolumeIcon;
				}
			}
		]]>
	</fx:Script>
	
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	
	<s:BorderContainer id="StatusBar" x="5" y="0" width="{this.minWidth - 10}" height="30" cornerRadius="3">
		<s:backgroundFill>
			<s:LinearGradient rotation="90">
				<s:GradientEntry color="0xf0f0f0"/>
				<s:GradientEntry color="0xd8d8d8"/>
			</s:LinearGradient>
		</s:backgroundFill>
		
		<s:Label id="mLevelLabel" x="5" y="3" text="PRACTICE LEVEL" width="318" textAlign="left" height="26" fontSize="14" verticalAlign="middle" fontWeight="bold" fontFamily="Georgia" fontStyle="normal" color="#669035"/>
		
		<s:Label id="mPlayersNameLabel" x="280" y="9" color="#7B9453" fontFamily="Arial" fontSize="16" fontWeight="bold" text="Player's Name:" />
		<s:TextInput id="mPlayerTextInput" x="400" y="2" width="110" height="24" change="onChangePlayerTextInput(event)" color="#7B9453" enabled="true"
					 fontSize="16" fontWeight="bold" text="Player" textAlign="left"/>
		
		<s:Image id="mVolumeImage" x="620" y="6" source="{mVolumeIcon}"/>
		<s:HSlider id="mVolumeSlider" x="645" y="9" width="80" change="updateVolume(mVolumeSlider.value)" dataTipPrecision="0" maximum="100" value="100"/>
	</s:BorderContainer>
	
	<s:Button id="mStartStopButton" x="20" y="46" width="100" height="30" label="Start" click="onClickStartStopButton(event)" enabled="true" fontSize="14" fontWeight="bold"/>
	<s:Button id="mChangeLevelButton" x="20" y="86" width="100" height="30" label="Change Level" click="onClickChangeLevelButton(event)" enabled="true" fontSize="12" fontWeight="bold"/>
	
	<s:BorderContainer id="mLogYardContainer" x="134" y="46" width="600" height="364" backgroundColor="#EAD1AA" borderVisible="false">
		<s:SWFLoader		id="mDynamicLog" x="-5" y="0" source="chainsaw_assets/DynamicLog.swf" complete="initLog1()" mouseUp="logUp(event)" mouseOver="logIn(event)" mouseOut="logOut(event)" mouseMove="logMidLog(event)" mouseChildren="false"/>
		<s:SWFLoader		id="mDynamicLog2" x="-5" y="0" source="chainsaw_assets/DynamicLog.swf" complete="initLog2()" mouseUp="logUp(event)" mouseOver="logIn(event)" mouseOut="logOut(event)" mouseMove="logMidLog(event)"/>
		<s:SWFLoader		id="mDynamicLog3" x="-5" y="0" source="chainsaw_assets/DynamicLog.swf" complete="initLog3()" mouseUp="logUp(event)" mouseOver="logIn(event)" mouseOut="logOut(event)" mouseMove="logMidLog(event)"/>
		<s:SWFLoader		id="mDynamicLog4" x="-5" y="0" source="chainsaw_assets/DynamicLog.swf" complete="initLog4()" mouseUp="logUp(event)" mouseOver="logIn(event)" mouseOut="logOut(event)" mouseMove="logMidLog(event)"/>
		<s:Group			id="mStatusLabelHolder" x="0" y="0" width="597" height="324" visible="false"/>
	</s:BorderContainer>
	
	<s:BorderContainer id="UI_Elements" x="0" y="156" width="134" height="274" backgroundColor="#EAD1AA" borderVisible="false">
		<s:Label id="mFuelLabel" x="15" y="-15" fontSize="16" fontWeight="bold" text="Fuel:"/>
		<s:SWFLoader id="mFuelIcon" x="15" y="5" width="106" height="118" complete="initGasTank()" source="chainsaw_assets/GasTank.swf" />
		<s:Label id="mReferenceLengthLabel" x="13" y="156" fontSize="16" fontWeight="bold" text="Target Length:"/>
		<mx:Image id="mTapeMeasure" x="15" y="182" source="{mTapeMeasureImage}"/>
		<mx:Image id="mReferenceLengthImage" x="15" y="216" source="{mLengthImage}"/>
	</s:BorderContainer>
	
	<mx:UIComponent	id="uic" x="0" y="0"/>
	
	<s:BorderContainer id="mResultsOverlay" x="0" y="0" width="{this.width}" height="{this.height}" alpha=".5" backgroundColor="#FFFFFF" borderColor="#FFFFFF" visible="false" click="{mResultsOverlay.visible=false}">
		<s:Label id="continue_msg" x="270" y="35" text="(Click anywhere to continue)"/>
		<s:Label id="mResults" x="{260+134}" y="50" fontSize="30" fontWeight="bold" text="Results"/>
		<s:Label id="mAcceptedPiecesLabel" x="102" y="145" width="323" fontSize="16"
				 fontWeight="bold" text="Number of Accepted Pieces:" textAlign="right"/>
		<s:Label id="mAcceptedPiecesValue" x="437" y="145" text="0" fontSize="16" verticalAlign="middle" fontWeight="bold" width="50" textAlign="left"/>
		<s:Label id="mFuelLeftLabel" x="174" y="225" width="251" fontSize="16" fontWeight="bold"
				 text="Fuel Left:" textAlign="right"/>
		<s:Label id="mFuelLeftValue" x="437" y="225" text="0" fontSize="16" verticalAlign="middle" fontWeight="bold" width="100" textAlign="left" visible="true"/>
		<s:Label id="mCutStyleLabel" x="350" y="308" text="Cut Style:" fontSize="16" verticalAlign="middle" fontWeight="bold" 
				 textAlign="right" visible="true"/>
		<s:Label id="mCutStyleValue" x="437" y="308" text="OTHER" fontSize="16" verticalAlign="middle" fontWeight="bold" width="220" textAlign="left" visible="true"/>
	</s:BorderContainer>
	
	<s:Label id="mVersionLabel" x="600" y="386" width="140" color="#666666" initialize="mVersionLabel.text=VERSION" textAlign="right" verticalAlign="bottom"/>
</s:Application>
