<?xml version="1.0" encoding="utf-8"?>
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009" 
			   xmlns:s="library://ns.adobe.com/flex/spark" 
			   xmlns:mx="library://ns.adobe.com/flex/mx" 
			   minWidth="600" minHeight="600" pageTitle="Chain Saw"
			   creationComplete="startUp( )">

	<fx:Script>
		<![CDATA[
			import chainsaw.GameLevelWindow;
			
			import flash.media.SoundMixer;
			
			import com.kcpt.scriptInterface.ScriptInterface;
			
			import mx.core.SoundAsset;
			import mx.core.UIComponent;
			import mx.effects.SoundEffect;
			import mx.managers.CursorManager;
			import mx.managers.PopUpManager;
			
			import spark.components.TitleWindow;
			import spark.core.SpriteVisualElement;
			import spark.events.TextOperationEvent;
			
			public var flashGasTank:MovieClip;
			public var sawdustParticles:MovieClip;
			public var dynamicLog1:MovieClip;
			
			public static const kTimeLimit:Number		= 20;		// Number of seconds player has to cut logs.
			public static const kRepeatSound:int		= 0;		// Play sound repeatedly.
			public static const kUpdatesPerSecond:Number= 4;		// Fuel tank updates per second.
			public static const kTotalUpdates:Number	= kTimeLimit * kUpdatesPerSecond; // Total number of updates.
			public static const kUpdateInterval:Number	= 1000 / kUpdatesPerSecond; // Milliseconds between updates.
			public static const kAlphaOpaque:Number		= 1;		// Opaque
			public static const kBlack:uint				= 0x000000;	// Black color.
			public static const kWhite:uint				= 0xFFFFFF;	// White color.
			public static const kReferenceLength:Number	= 75;		// Reference length in pixels of 16" piece.
			public static const kPercentAllowance:Number= ((1.0/8.0)*100);		// Percent allowed above or below accepted cut length.
			public static const kConvertToInches:Number	= 16.0/kReferenceLength;// Used to convert pixel length to 16".
			public static const kCutEdgeLeftXOffset:int	= -60;		// X offset of left "Cut Edge" Label.
			public static const kCutEdgeRightXOffset:int= 1;		// X offset of right "Cut Edge" Label.
			public static const kCutEdgeLeftYOffset:int	= -2;		// X offset of left "Cut Edge" Label.
			public static const kCutEdgeRightYOffset:int= -2;		// X offset of right "Cut Edge" Label.
			public static const kLogStartY:Number		= 38;		// Starting Y of top log.
			public static const kLogOffsetY:int			= 69;		// Y offset from previous log.
			public static const kFuelCapacity:Number	= 40;		// Units of fuel when full.
			//levels
			public static const kPracticeLevel:uint		  = 0;		// Practice level.
			public static const kDirectionalCutLevel:uint = 1;		// Directional cut level.
			public static const kFreeCutLevel:uint		  = 2;		// Free cut level.
			
			// Collection names according to level played.
			public static const kCollectionDirCutPieces:String	= "CutPieces - Directional Cut Level";
			public static const kCollectionFreeCutPieces:String	= "CutPieces - Free Cut Level";
			public static const kCollectionDirCutGames:String	= "Games - Directional Cut Level";
			public static const kCollectionFreeCutGames:String	= "Games - Free Cut Level";
			
			// Strings indicating accptance/rejection status of cut pieces.
			public static const kAcceptString:String		= "Yes";
			public static const kRejectShortString:String	= "No-Short";
			public static const kRejectLongString:String	= "No-Long";
			
			// Minimum accepted cut length in pixels.
			public static const kMinCutLength:Number	= kReferenceLength * (1.0 - (kPercentAllowance / 100));	
			// Maximum accepted cut length in pixels.
			public static const kMaxCutLength:Number	= kReferenceLength * (1.0 + (kPercentAllowance / 100));	
			
			// Create a timer to update the fuel level display and game duration.
			private var mFuelTimer:Timer = new Timer(kUpdateInterval, kTotalUpdates);
			
			// Used for drawing the down arrow.
			private var mArrowSprite:SpriteVisualElement = new SpriteVisualElement();
			private var mArrowBitmapData:BitmapData;
			
			//the sawdust pile
			private var mSawdustSprite:SawdustSprite = new SawdustSprite();

			private var mFirstGame:Boolean			= true;	// Used for initial operations.
			private var mGameLevel:uint				= 0;	// Current game level.
			private var mPrevLevel:uint				= 0;	// Used to track level changes.
			private var mDirCutCollectionCreated:Boolean = false;	// Collection created on first play at each level.
			private var mFreeCutCollectionCreated:Boolean = false;	// Collection created on first play at each level.
			private var mLevelWindow:GameLevelWindow;		// The modal window for choosing a game level.
			private var mLogsPerGame:uint			= 4;	// Number of logs being used in each game.
			private var mFuelUsed:Number			= 0;	// Stores how many units of fuel have been used.
			private var mChainsawCursorID:Number	= 0;	// Holds a cursor ID.
			private var mGameNumber:uint			= 0;	// Keeps track of games since app launch. Practice level ignored.
			private var mCurrentLog:uint			= 1;	// Current log being cut. 1 based.
			private var mLastLog:uint				= 0;	// Number of log at most recent cut. 1 based. 0 before cuts.
			private var mLastCutX:Number			= 0;	// X location of most recent cut.
			private var mLeftToRight:Boolean		= true;	// Current cutting direction of log.
			private var mStatusArray:Array = new Array;		// Holds status labels put on cut logs.
			private var mPiecesAccepted:uint		= 0;	// Number of cut pieces accepted.
			private var mPiecesRejected:uint		= 0;	// Number of cut pieces rejected.
			private var mPlayersName:String			= "Player"; // Stores player's name.
			
			// These arrays store the details of individual logs for access by all who need to know.
			private var mLogDetails1:Array;
			private var mLogDetails2:Array;
			private var mLogDetails3:Array;
			private var mLogDetails4:Array;
			
			// Stores array of logs/logtops used in game.
			private var mLogArray:Array;
			
			// Holds piece number beginning at 1 for each cut piece since start of application.
			// Transmitted to TinkerPlots/Fathom. Practice level ignored.
			private var mPieceNumber:uint			= 0;	
			
			// Holds value of piece count as of previous game. Used in free cut levels to calculate
			// piece numbers in cut order rather than location on log.
			private var mPrevPieceNumber:uint		= 0;
			
			// Holds cut number beginning at 1 for cuts made in free cut levels.
			private var mCutNumber:uint				= 0;
			
			// Embed the cursor symbol.
			// From http://www.rw-designer.com/cursor-download.php?id=2222 on 12/11/2010
			// Converted from .ani format to .swf.
//			[Embed(source="../assets/Chainsaw Cursor 2.swf")]
			// Converted from .ani format to .png.
			[Embed(source="../assets/Chainsaw Cursor 2.png")]
			private var mChainsawCursor:Class;

			// Embed the reference length image file.
			[Embed(source="../assets/Reference Length 75 Pixels.png")]
			[Bindable]
			private var mLengthImage:Class;
			
			// Embed tape measure image
			[Embed(source="../assets/tape_measure.png")]
			[Bindable]
			private var mTapeMeasureImage:Class;
			
			// Embed the down arrow image file.
			[Embed(source="../assets/Down Arrow Small.png")]
			[Bindable]
			private var mDownArrowImage:Class;
			
			//Embed sawdust pile image
			[Embed(source="../assets/sawdust_pile.png")]
			[Bindable]
			private var mSawdustPile:Class;
			
			// From http://www.hark.com/clips/dvghjtvdvr-chainsaw-clip on 12/11/2010
			// Converted from .m4a format to .mp3.
//			[Embed("../src/assets/Chainsaw Sound.mp3")]
			// From http://www.pacdv.com/sounds/machine_sound_effects/chain-saw-2.mp3 on 12/12/2010
			// Using most of clip but not when engine shuts down.
			[Embed("../src/assets/Chainsaw Sound Longer.mp3")]
			private var ChainsawMP3:Class;
			
			// From http://www.pacdv.com/sounds/machine_sound_effects/chain-saw-2.mp3 on 12/12/2010
			// Using only end of clip when engine shuts down.
			[Embed("../src/assets/Chainsaw Engine Stops no Fade In.mp3")]
			private var EngineStopsMP3:Class;
			private var mEngineStopsSound:SoundAsset = new EngineStopsMP3() as SoundAsset;
			
			
			[Embed("../src/assets/Chainsaw Sound Longer.mp3")]
			private var ChainsawSoundMP3:Class;
			private var mChainsawSound2:SoundAsset = new ChainsawSoundMP3() as SoundAsset;

			// startUp() is called when the creation of this class is complete
			// and sets up necessary parameters for game initiation.
			private	function startUp():void
			{
				// Arrays store individual cuts on each log for use in free cut levels.
				var log1Cuts:Array = new Array();		
				var log2Cuts:Array = new Array();
				var log3Cuts:Array = new Array();
				var log4Cuts:Array = new Array();
				
				mLogDetails1 = new Array(mLog1, mLog1Top, log1Cuts);
				mLogDetails2 = new Array(mLog2, mLog2Top, log2Cuts);
				mLogDetails3 = new Array(mLog3, mLog3Top, log3Cuts);
				mLogDetails4 = new Array(mLog4, mLog4Top, log4Cuts);
				
				// Stores array of logs/logtops used in game.
				// Create new log array and add log/logtop to array.
				mLogArray = new Array(mLogDetails1, mLogDetails2, mLogDetails3, mLogDetails4);
				
				// Randomize log array.
				randomizeLogOrder();
				
				mLogArray[0][1].alpha	= 1;	// Show top cutting edge on the top log.
				mLogArray[1][1].alpha	= 0;	// Hide top cutting edge on all other logs...
				mLogArray[2][1].alpha	= 0;	
				mLogArray[3][1].alpha	= 0;
				
				// Move "Cut Edge" labels to first log.
				mCutEdgeLeftLabel.x		= mLogArray[0][1].x + kCutEdgeLeftXOffset;
				mCutEdgeLeftLabel.y		= mLogArray[0][1].y + kCutEdgeLeftYOffset;
				mCutEdgeRightLabel.x	= mLogArray[0][1].x + mLogArray[0][1].width + kCutEdgeRightXOffset;
				mCutEdgeRightLabel.y	= mLogArray[0][1].y + kCutEdgeRightYOffset;
				
				// Set sound effect duration to full length of chainsaw sound.
				mChainsawSound.duration = mChainsawSound.sound.length;
				
				// Load and draw the bitmap of the cut location arrow.
				mArrowBitmapData = new mDownArrowImage().bitmapData;
				mArrowSprite.blendMode = "multiply";
				mArrowSprite.graphics.clear();
				mArrowSprite.graphics.beginBitmapFill(mArrowBitmapData);
				mArrowSprite.graphics.drawRect(0, 0, mArrowBitmapData.width, mArrowBitmapData.height);
				mArrowSprite.graphics.endFill();
				mArrowSprite.x = mLogArray[0][0].x - (mArrowBitmapData.width / 2);	// Start with arrow pointing at left edge of first log.
				mArrowSprite.y = mLogArray[0][0].y - mArrowBitmapData.height;			// Start at top edge of first log.
				mLogYardContainer.addElement(mArrowSprite);
				
				//TODO sawdust pile sprite
				mSawdustSprite.init();
				mSawdustSprite.scaleX = .2;
				mSawdustSprite.scaleY = .2;
				mSawdustSprite.x = 100;
				//addElement(mSawdustSprite); //TODO
				
				
				mLevelWindow = new GameLevelWindow();
				//chooseGameLevel();
				//practiceLevel(new Event(Event.INIT));//start game in pratice mode by default
			}
			
			// clearGame() resets the game according to the current level and clears remnants of
			// the previous game, if any.
			private function clearGame(iNewGameLevel:uint):void
			{
				// Move "Cut Edge" labels to first log.
				mCutEdgeLeftLabel.x		= mLogArray[0][1].x + kCutEdgeLeftXOffset;
				mCutEdgeLeftLabel.y		= mLogArray[0][1].y + kCutEdgeLeftYOffset;
				mCutEdgeRightLabel.x	= mLogArray[0][1].x + mLogArray[0][1].width + kCutEdgeRightXOffset;
				mCutEdgeRightLabel.y	= mLogArray[0][1].y + kCutEdgeRightYOffset;
				
				// Enable/show log cutting edge. Clear all cuts in array.
				for (var i:Number = 0; i < mLogsPerGame; ++i)
				{
					if (iNewGameLevel == kFreeCutLevel)
					{
						// Clear cut lists on log.
						while (mLogArray[i][2].length > 0)
							mLogArray[i][2].pop();
					}	
					
					mLogArray[i][0].removeAllElements(); // Remove all drawn items from log.
					
					// Top log
					// Directional cut levels begin with one log top active at a time. All log tops are active in free cut levels.
					if ((i == 0) || (iNewGameLevel == kFreeCutLevel)) 
					{
						mLogArray[i][1].alpha	= 1;	// Show top cutting edge on the log.
						mLogArray[i][1].enabled	= true;	// Enable mouseover and mousedown testing on the log.
					}
						// Lower logs
					else		
					{
						mLogArray[i][1].alpha	= 0;	// Hide top cutting edge the log.
						mLogArray[i][1].enabled	= false;// Disable mouseover and mousedown testing on the.
					}
				}
				
				mAcceptedPiecesValue.visible = false; // Hide number of accepted pieces until game is complete.
				
				if (iNewGameLevel == kFreeCutLevel)
					mArrowSprite.visible == false;	// Hide arrow in free cut mode.
				else
				{
					mArrowSprite.visible == true;	// Show arrow in free cut mode.
					
					// Move arrow back to start of first log.
					mArrowSprite.x = mLogArray[0][0].x - (mArrowBitmapData.width / 2);	// Start with arrow pointing at left edge of first log.
					mArrowSprite.y = mLogArray[0][0].y - mArrowBitmapData.height;			// Start at top edge of first log.
				}
				
				// Set fuel height back to top of fuel container.
				flashGasTank['resetDrop']();
				
				mFuelUsed = 0;		// Initialize the fuel used to zero.
			}
			
			// chooseGameLevel() listens for clicks on the level dialog's level buttons.
			private function chooseGameLevel():void 
			{
				var isModal:Boolean = true;
				PopUpManager.addPopUp(mLevelWindow, this, isModal); 
				
				PopUpManager.centerPopUp(mLevelWindow);		// Center the window.
				mLevelWindow.closeButton.visible = false;	// Hide the close button.
				
				mLevelWindow["mPracticeLevelButton"].addEventListener("click", practiceLevel);   
				mLevelWindow["mDirectionalCutButton"].addEventListener("click", directionalCutLevel);   
				mLevelWindow["mFreeCutButton"].addEventListener("click", freeCutLevel);   
			}
			
			// gameLevelChosen() sets the current game level to the value passed in and closes the modal
			// dialog.
			private function gameLevelChosen(iLevel:uint):void 
			{
				mGameLevel = iLevel; // Set game level to practice.
				
				PopUpManager.removePopUp(mLevelWindow);
			}
			
			// practiceLevel() sets the current game level to practice.
			private function practiceLevel(iEvent:Event):void 
			{
				mPrevLevel = mGameLevel;		// Track game level change.
				
				// If changing levels, clear any remnants of last game and reset game.
				if (mGameLevel != kPracticeLevel)
				{
					randomizeLogOrder(); 			// Randomize logs before clearing.
					clearGame(kPracticeLevel); 
				}

				gameLevelChosen(kPracticeLevel); // Set game level to practice.
				mLevelLabel.text			= "PRACTICE LEVEL";
				
				mCutEdgeLeftLabel.visible	= true;	// Show "Cut Edge" labels.
				mCutEdgeRightLabel.visible	= true;
				mArrowSprite.visible		= true; // Show cut location arrow.
			}
			
			// directionalCutLevel() sets the current game level to directional cut.
			private function directionalCutLevel(iEvent:Event):void 
			{
				// If changing levels, clear any remnants of last game and reset game.
				if (mGameLevel != kDirectionalCutLevel)
				{
					mPrevLevel = mGameLevel;			// Track game level change.
					randomizeLogOrder(); 				// Randomize logs before clearing.
					clearGame(kDirectionalCutLevel); 
				}
				
				gameLevelChosen(kDirectionalCutLevel); // Set game level to practice.
				mLevelLabel.text = "DIRECTIONAL CUT LEVEL";
				
				mCutEdgeLeftLabel.visible	= true;	// Show "Cut Edge" labels.
				mCutEdgeRightLabel.visible	= true;
				mArrowSprite.visible		= true; // Show cut location arrow.

				if (!mDirCutCollectionCreated)
				{
					createCollection(kCollectionDirCutPieces, kCollectionDirCutGames);
					mDirCutCollectionCreated = true;
				}
			}
			
			// freeCutLevel() sets the current game level to free cut.
			private function freeCutLevel(iEvent:Event):void 
			{
				// If changing levels, clear any remnants of last game and reset game.
				if (mGameLevel != kFreeCutLevel)
				{
					mPrevLevel = mGameLevel;		// Track game level change.
					randomizeLogOrder(); 			// Randomize logs before clearing.
					clearGame(kFreeCutLevel); 
				}
				
				gameLevelChosen(kFreeCutLevel); // Set game level to practice.
				mLevelLabel.text = "FREE CUT LEVEL";

				mCutEdgeLeftLabel.visible	= false; // Hide "Cut Edge" labels.
				mCutEdgeRightLabel.visible	= false;
				mArrowSprite.visible		= false; // Hide cut location arrow.

				if (!mFreeCutCollectionCreated)
				{
					createCollection(kCollectionFreeCutPieces, kCollectionFreeCutGames);
					mFreeCutCollectionCreated = true;
				}
			}
			
			//called by directionalCutLevel() and freeCutLevel()
			private function createCollection(collection1:String, collection2:String):void
			{
				if(collection1==kCollectionDirCutPieces){//has the extra attribute, isEndPiece
					// Create collection for individual cut pieces.
					ScriptInterface.NewCollectionWithAttributes(
						collection1,
						[
							"PieceNumber",		// Piece number starting with 1 since launch of application.
							"Player",			// Name of the player.
							"GameNumber",		// Game number starting with 1 since launch of application.
							"Length",			// Length of cut piece.
							"Accepted",			// True if cut piece is within accepted range of cut length.
							"EndPiece",			// Yes if this piece is an end piece.
							"LogNumber",		// Number of log from which piece was cut.
							"FuelLeftAmount",	// Raw amount of fuel left at the time of piece creation.
							"FuelLeftPercent"	// Percent of fuel left at the time of piece creation.
						]
					);
				}
				else {
					// Create collection for individual cut pieces.
					ScriptInterface.NewCollectionWithAttributes(
						collection1,
						[
							"PieceNumber",		// Piece number starting with 1 since launch of application.
							"Player",			// Name of the player.
							"GameNumber",		// Game number starting with 1 since launch of application.
							"Length",			// Length of cut piece.
							"Accepted",			// True if cut piece is within accepted range of cut length.
							"LogNumber",		// Number of log from which piece was cut.
							"FuelLeftAmount",	// Raw amount of fuel left at the time of piece creation.
							"FuelLeftPercent"	// Percent of fuel left at the time of piece creation.
						]
					);
				}
				
				// Create collection for each game.
				ScriptInterface.NewCollectionWithAttributes(
					collection2,
					[
						"GameNumber",		// Game number starting with 1 since launch of application.
						"Player",			// Name of the player.
						"PiecesAccepted",	// Number of pieces accepted.
						"PiecesRejected",	// Number of pieces rejected.
						"FuelLeftAmount",	// Raw amount of fuel left.
						"FuelLeftPercent"	// Percent of fuel left.
					]
				);
			}
			
			//**TRISTAN: This is a quad array swap... the logs don't change just where they are in the array and on screen...
			// randomizeLogOrder() randomly resorts the logs in the log array.
			protected function randomizeLogOrder():void
			{
				var j:Number = 0;
				var temp:Array;
				
				for (var i:Number = 0; i < mLogsPerGame; ++i) 
				{
					// Do the random swap.
					j = Math.floor(Math.random() * (i + 1));
					temp = mLogArray[i];
					mLogArray[i] = mLogArray[j];
					mLogArray[j] = temp;
					
					// Set the y position to follow the array order. Otherwise, the 
					// swapped logs will still be drawn in the same position as before 
					// the swap.
					mLogArray[i][0].y = kLogStartY + (i * kLogOffsetY);	// Y position log i.
					mLogArray[i][1].y = kLogStartY + (i * kLogOffsetY);	// Y position log top i.
					mLogArray[j][0].y = kLogStartY + (j * kLogOffsetY);	// Y position log j.
					mLogArray[j][1].y = kLogStartY + (j * kLogOffsetY);	// Y position log top i.
				}
			}
			
			// recordPieceStatus() evaluates the piece's acceptance status and records the outcome
			// by setting a visual marker on each log and also transmitting the info to 
			// Fathom/TinkerPlots.
			protected function recordPieceStatus(iLength:Number,		// Piece length
												 iLogNumber:uint, 		// Number of log ( 1 is at top).
												 iIsEndPiece:Boolean, 	// True if end piece.
												 iLeftToRight:Boolean,	// True if cutting left to right.
												 iIsNewLog:Boolean,		// True if measuring on new log for first time.
												 iFuelUsed:Number,		// Raw fuel used at the time of piece creation.
												 iPrevXCut:Number = 0,	// Cut before this cut or game end.
												 iCutX:Number = 0,		// X cut location on log. 0 if end piece.
												 iPieceNumber:uint = 0	// Piece number. If not 0, transmit this number instead of mPieceNumber.
												):void
			{
				// Not cutting, so don't specify a cut location.
				if (iIsEndPiece)
					iCutX = 0;
				
				// Create "X" or "√" for piece to indicate rejected or accepted.
				var statusLabel:Label	= new Label();
				statusLabel.width		= 14;			// Setting manually, as measureText() fails with Spark Label.
				statusLabel.height		= 14;
				statusLabel.visible	= false;		// Hide labels until game completes.
				statusLabel.setStyle("fontWeight", "bold");
				statusLabel.setStyle("fontSize", "16");
				statusLabel.setStyle("antiAliasType", "normal");
				statusLabel.setStyle("justificationStyle", "auto");
					
				// Accept cut piece if it falls within accepted range.
				var accepted:Boolean = (iLength >= kMinCutLength) && (iLength <= kMaxCutLength);
				var acceptString:String;
					
				// Keep track of how many cut pieces are accepted / rejected and set status label text.
				if (accepted)
				{
					if (mGameLevel != kPracticeLevel)
						++mPieceNumber;
					++mPiecesAccepted;
					statusLabel.text	= "√";					// Check mark = OK.
					statusLabel.setStyle("color", "0x00FF00");	// Green = OK.
					acceptString = kAcceptString;
				}
				else								
				{
					if (mGameLevel != kPracticeLevel)
						++mPieceNumber;
					++mPiecesRejected;
					statusLabel.text = "X";					// X = not OK.
					statusLabel.setStyle("color", "0xFF0000");	// Red = not OK.
					acceptString = (iLength < kMinCutLength) ? kRejectShortString : kRejectLongString;
				}
					
				// Set y location of status label for cut piece.
				statusLabel.y = (mLogArray[iLogNumber-1][0].height / 2) - (statusLabel.height / 2);
				
				// Set x location of status label for cut piece.
				if (iLeftToRight)
				{
					// End piece or cutting along same log as at the last cut.
					if (iIsEndPiece || (!iIsEndPiece && !iIsNewLog))
						statusLabel.x = iPrevXCut + (iLength / 2) - (statusLabel.width / 2);
					// Cutting on new log.
					else
						statusLabel.x = (iLength / 2) - (statusLabel.width / 2);
				}
				else
					statusLabel.x = iCutX + (iLength / 2) - (statusLabel.width / 2);
				
				mStatusArray.push(statusLabel);	// Add label to array for later display.
				
				mLogArray[iLogNumber-1][0].addElement(statusLabel); 		// Add label to current log's display list.
					
				if (mGameLevel != kPracticeLevel)
				{
					var lengthTwoDecimals:String	= (iLength * kConvertToInches).toFixed(2);
					var fuelLeftFraction:Number		= 1 - (iFuelUsed / kTotalUpdates);
					var fuelLeftAmount:Number		= fuelLeftFraction * kFuelCapacity;
					var fuelLeftPercent:Number		= fuelLeftFraction * 100;
					var pieceNumber:uint 			= iPieceNumber == 0 ? mPieceNumber : iPieceNumber;
					
					var collectionName:String;
					
					// Send info on cut pieces to TinkerPlots/Fathom.
					if (mGameLevel == kDirectionalCutLevel)
					{
						var isEnd:String 			= iIsEndPiece ? "Yes" : "No";
						
						collectionName = kCollectionDirCutPieces;//TODO replace these AddCaseToCollectionWithValues() calls with a single one
						
						ScriptInterface.AddCaseToCollectionWithValues(
							kCollectionDirCutPieces, 
							[
								pieceNumber,		// Piece number since application launch. Ignore practice level.
								mPlayersName,		// Name of the player.
								mGameNumber,		// Game number starting with 1 since launch of application.  Ignore practice level.
								lengthTwoDecimals,	// Piece length.
								acceptString,		// Status of cut piece.
								isEnd,				// "Yes" if it is an end piece.
								iLogNumber,			// Number of log from which piece was cut.
								fuelLeftAmount,		// Raw fuel left at the time of piece creation.
								fuelLeftPercent		// Percent of fuel left at the time of piece creation.

							]	
						);
					}
					else
					{
						collectionName = kCollectionFreeCutPieces;//TODO
						
						ScriptInterface.AddCaseToCollectionWithValues(
							kCollectionFreeCutPieces, 
							[
								pieceNumber,		// Piece number since application launch. Ignore practice level.
								mPlayersName,		// Name of the player.
								mGameNumber,		// Game number starting with 1 since launch of application.  Ignore practice level.
								lengthTwoDecimals,	// Piece length.
								acceptString,		// Status of cut piece.
								iLogNumber,			// Number of log from which piece was cut.
								fuelLeftAmount,		// Raw fuel left at the time of piece creation.
								fuelLeftPercent		// Percent of fuel left at the time of piece creation.
	//							iLog.height * kConvertToInches	// Thickness of log from which piece was cut.
							]	
						);
					}
				}
			}
			
			// endGame() performs all operations necessary when game is complete.
			protected function endGame():void
			{
				if (mGameLevel != kPracticeLevel)
				{
					mFuelTimer.stop();													// Stop fuel timer.
					mFuelTimer.removeEventListener(TimerEvent.TIMER, timerListener);	// Stop listening.
					flashGasTank['pauseDrop']();	//stop gas tank animation
				}
				
				CursorManager.removeCursor(mChainsawCursorID);	// Remove chainsaw cursor.
				mChainsawSound.stop();							// Stop playing chainsaw sound.
				mEngineStopsSound.play();						// Play chainsaw engine stopping sound.
				
				if (mGameLevel == kFreeCutLevel)
				{
					// Stores individual pieces to be sorted by cut order in a second pass.
					var pieceStatusArray:Array = new Array;
					
					// For each log
					for (var ii:Number = 0; ii < mLogsPerGame; ++ii) 
					{
						// Sort log's cutlist left to right. Must specify NUMERIC or sort will be by string.
						mLogArray[ii][2].sortOn("mCutX", Array.NUMERIC);
						
						var prevCut:Number	= 0;	// Start at the left edge of the log.
						
						// For each cut position
						for (var j:Number = 0; j < mLogArray[ii][2].length; ++j)
						{
							var length:Number		= 0;		// Length of piece.
							var isEnd:Boolean		= false;	// No end pieces in free cut level.
							var leftToRight:Boolean	= true;		// Measuring left ot right.
							
							// Piece number for free cut is in cut order, not location on log.
//							var pieceNumber:uint	= mLogArray[ii][2][j].mCutNumber + pieceNumberBase;
							
							// Calculate the piece length and transmit to TinkerPlots/Fathom.
							length = mLogArray[ii][2][j].mCutX - prevCut;
							
							var pieceStatus:PieceStatus = 
								new PieceStatus(
										length,						// Piece length.
										ii + 1, 					// Number of log (1 is at top).
										isEnd, 						// True if end piece.
										leftToRight,				// True if cutting left to right.
										prevCut == 0,				// True if measuring on new log for first time.
										mLogArray[ii][2][j].mFuelUsed,// Raw fuel left at the time of piece creation.
										prevCut,					// Cut before this cut or game end.
										mLogArray[ii][2][j].mCutX,	// X cut location on log. 0 if end piece.
										mLogArray[ii][2][j].mCutNumber// Cut number. 
									);
							
							pieceStatusArray.push(pieceStatus);
							prevCut = mLogArray[ii][2][j].mCutX;	// Save previous cut position.
							
							// Calculate the rightmost piece length, if it's the final cut.
							if (j == (mLogArray[ii][2].length - 1))
							{
								// Used to increment next cut numbers and provide sequential pieece numbers.
								++pieceNumberBase; 
								
								var lastLength:Number;
								lastLength = mLogArray[ii][0].width - mLogArray[ii][2][j].mCutX;
								
								var endPieceStatus:PieceStatus = 
									new PieceStatus(
										lastLength,					// Piece length.
										ii + 1, 					// Number of log (1 is at top).
										isEnd, 						// True if end piece.
										leftToRight,				// True if cutting left to right.
										false,						// True if measuring on new log for first time.
										mLogArray[ii][2][j].mFuelUsed, // Raw fuel left at the time of piece creation.
										prevCut,					// Cut before this cut or game end.
										0,							// X cut location on log. 0 if end piece.
										mLogArray[ii][2][j].mCutNumber// Cut number.  
									);
								
								pieceStatusArray.push(endPieceStatus);
							}
						}
					}
					
					// In second pass, sort pieces by cut number and use these cut numbers to 
					// calculate piece numbers, taking end pieces into account.
					pieceStatusArray.sortOn("mCutNumber", Array.NUMERIC);
					
					// Used in calculating piece numbers.
					var pieceNumberBase:uint	= mPrevPieceNumber;
					var prevCutNumber:uint		= 0;
					
					// For each cut position
					for (var k:Number = 0; k < pieceStatusArray.length; ++k)
					{
						if (pieceStatusArray[k].mCutNumber == prevCutNumber)
							++pieceNumberBase;
						
						// Transmit to TinkerPlots/Fathom.
						recordPieceStatus(	
							pieceStatusArray[k].mLength,			
							pieceStatusArray[k].mLogNumber, 		
							pieceStatusArray[k].mIsEndPiece, 	
							pieceStatusArray[k].mLeftToRight,	
							pieceStatusArray[k].mIsNewLog,		
							pieceStatusArray[k].mFuelUsed,		
							pieceStatusArray[k].mPrevXCut,	
							pieceStatusArray[k].mCutX,		
							pieceStatusArray[k].mCutNumber + pieceNumberBase
						);
						
						prevCutNumber = pieceStatusArray[k].mCutNumber; // Track previous cut number.
					}
				}
				// Directional cut mode. Measure end piece if player has already started cutting current log.
				else if (mCurrentLog == mLastLog)
				{
					// Calculate distance from end of log in the direction player was cutting.
					// mCurrentLog begins at 1. Array index begins at 0.
					var woodRemaining:Number	= mLeftToRight? mLogArray[mCurrentLog-1][0].width - mLastCutX : mLastCutX;
					var isEndPiece:Boolean		= true;
					
					// Evaluate the piece's acceptance status and record the outcome by setting a 
					// visual marker on each log and also transmit the info to Fathom/TinkerPlots.
					recordPieceStatus(	
						woodRemaining, 			// Piece length
						mCurrentLog, 			// Number of log ( 1 is at top).
						isEndPiece, 			// True if end piece.
						mLeftToRight, 			// True if cutting left to right.
						mCurrentLog != mLastLog,// True if measuring on new log for first time.
						mFuelUsed,				// Raw fuel used at the time of piece creation.
						mLastCutX);				// X cut location on log. 0 if end piece.
				}
				
				mStartButton.enabled			= true;
				mChangeLevelButton.enabled		= true;
				mStopButton.enabled				= false;
				mPlayerTextInput.enabled		= true;
				
				mAcceptedPiecesValue.text		= mPiecesAccepted.toString();	// Update text to number of accepted pieces.
				mAcceptedPiecesValue.visible	= true;	// Reveal number of accepted pieces in this game.
				
				// Show status labels on each cut piece.
				for (var i:Number = 1; i <= mPiecesAccepted + mPiecesRejected; ++ i)
				{
					var resultLabel:Label = mStatusArray.pop();
					resultLabel.visible = true;
				}
				
				if (mGameLevel != kPracticeLevel)
				{
					var fuelLeftFraction:Number	= 1 - (mFuelUsed / kTotalUpdates);
					var fuelLeftAmount:Number	= fuelLeftFraction * kFuelCapacity;
					var fuelLeftPercent:Number	= fuelLeftFraction * 100;
					var gameCollectionName:String	
						= (mGameLevel == kFreeCutLevel) ? kCollectionFreeCutGames : kCollectionDirCutGames;
						
					// Send info on games to TinkerPlots/Fathom.
					ScriptInterface.AddCaseToCollectionWithValues(
						gameCollectionName, 
						[
							mGameNumber,		// Game number starting with 1 since launch of application.
							mPlayersName,		// Name of the player.
							mPiecesAccepted,	// Number of pieces accepted.
							mPiecesRejected,	// Number of pieces rejected.
							fuelLeftAmount,		// Raw amount of fuel left.
							fuelLeftPercent		// Percent of fuel left.
						]	
					);
				}
				
				mPrevLevel 			= mGameLevel;	// Track game level change.
				mPrevPieceNumber	= mPieceNumber;	// Track piece number at the end of the game.
			}
			
			// timerListener() is called to update the fuel level display and game duration.
			// now just updates the mFuelUsed
			protected function timerListener(iEvent:TimerEvent):void
			{
				// Increment the units of fuel used at the start, as this amount was used since 
				// the start or previous timer interval.
				++mFuelUsed;
				
				// If there is still fuel left, provide updates and effects used during game play.
				if (mFuelUsed < kTotalUpdates)
				{
					//removed old code that just updates the fuel display
					//no longer needed with new fuel tank
				}
				// Fuel has been consumed and game is over.
				else
				{
					endGame();
				}
			}

			// onClickStartButton() is called whenever the start button is pressed.
			protected function onClickStartButton(iEvent:MouseEvent):void
			{
				// Set game number since app launch when new game starts, not counting practice level).
				if (mGameLevel != kPracticeLevel)
					++mGameNumber;	
				
				mLastLog			= 0;	// Reset last cut log counter.
				mCurrentLog			= 1;	// Reset log counter.
				mLastCutX			= 0;	// Reset X position of most recent cut.
				mPiecesAccepted		= 0;	// Reset number of cut pieces accepted.
				mPiecesRejected		= 0;	// Reset number of cut pieces rejected.
				mLeftToRight		= true;	// Begin cutting left to right.
				mCutNumber			= 0;	// Reset cut number.
				
				// Randomize log array, but not for first game, as it's already random.
				if (!mFirstGame)
				{
					// Don't randomize if this was just done on level change.
					if (mPrevLevel == mGameLevel)
						randomizeLogOrder();
				}
				else
					mFirstGame = false;
				
				clearGame(mGameLevel); // Clear any remnants of last game and reset game.
				
				mStartButton.enabled		= false;
				mChangeLevelButton.enabled	= false;
				mStopButton.enabled			= true;
				mPlayerTextInput.enabled	= false;
				mChainsawCursorID			= CursorManager.setCursor(mChainsawCursor);
				
				// Use timer to update the fuel level display and game duration.
				if (mGameLevel != kPracticeLevel)
				{
					mFuelTimer.addEventListener(TimerEvent.TIMER, timerListener);
					
					
					mFuelTimer.reset();	// Reset the timer to run until fuel runs out.
					mFuelTimer.start(); // Start the timer, now that all variables are set up.
					flashGasTank['initGasTank'](kTimeLimit * 24);
					flashGasTank['startDrop']();
				}
			}
			
			// cutLogInOrder() performs all cutting operations when the passed in log is cut at 
			// the x position being passed in. The x position is in the coordinate system
			// of the log being cut.
			protected function cutLogInOrder(	iLogNumber:uint, 
											 	iLog:BorderContainer,
											 	iLogTop:BorderContainer, 
											 	iLocalX:Number,
											 	iLeftToRight:Boolean,
											 	iNextLogTop:BorderContainer = null,
											 	iTopToBottom:Boolean = true
												):void
			{
				// Don't cut if chainsaw is not running and we're not in practice mode.
				if (mGameLevel != kPracticeLevel)
				{
					if (!mFuelTimer.running)
						return;
				}
				
				var newArrowXPosition:Number = iLog.x + iLocalX - (mArrowBitmapData.width / 2) + 1;
				
				// Only cut in specified direction.
				if ((iLeftToRight && mArrowSprite.x < newArrowXPosition) || 
					(!iLeftToRight && mArrowSprite.x > newArrowXPosition))
				{
					var cutWidth:Number	= 1;	// Pixel width of cut.
					
					// Draw cut line vertically.
					var logSprite:SpriteVisualElement= new SpriteVisualElement();	
					logSprite.graphics.lineStyle(cutWidth, kWhite);
					
					if (iTopToBottom)
					{
						logSprite.graphics.moveTo(iLocalX, 0);
						logSprite.graphics.lineTo(iLocalX, iLog.height);
					}
					else
					{
						logSprite.graphics.moveTo(iLocalX, iLog.height);
						logSprite.graphics.lineTo(iLocalX, 0);
					}
					
					iLog.addElement(logSprite); 	// Add cut line to current log's display list.
					
					// Calculate distance from end of log in the direction player is cutting.
					var woodRemaining:Number	= iLeftToRight? iLog.width - iLocalX : iLocalX;
					
					// If player has wood to cut, the intended cut is not an end piece.
					var isEndPiece:Boolean		= false; 

					// If there is not enough wood left to do another acceptable cut on this 
					// log or the end piece is within the acceptable length range AND if there
					// remains another log to cut, move the arrow cursor to the next log and 
					// prepare to cut this next log.
					if	(iNextLogTop && (woodRemaining <= kMaxCutLength))
					{
						isEndPiece			= true;	// Remainder of log counts as an end piece.
						iLogTop.enabled		= false;// Stop further cuts on this log.
						iLogTop.alpha		= 0.0;	// Hide top cutting edge.
						iNextLogTop.enabled	= true;	// Enable cuts on this log.
						iNextLogTop.alpha	= 100.0;// Show top cutting edge.
						
						mArrowSprite.y = iNextLogTop.y - mArrowBitmapData.height;		// Start at top edge of next log.
						mArrowSprite.x = iNextLogTop.x - (mArrowBitmapData.width / 2);	// Start with arrow pointing at left edge of next log.
						if (iLeftToRight)
							mArrowSprite.x += iNextLogTop.width;	// Move to right end of log if just cut left to right.
						
						// Move "Cut Edge" labels to next log.
						mCutEdgeLeftLabel.x		= iNextLogTop.x + kCutEdgeLeftXOffset;
						mCutEdgeLeftLabel.y		= iNextLogTop.y + kCutEdgeLeftYOffset;
						mCutEdgeRightLabel.x	= iNextLogTop.x + iNextLogTop.width + kCutEdgeRightXOffset;
						mCutEdgeRightLabel.y	= iNextLogTop.y + kCutEdgeRightYOffset;
						
						++mCurrentLog;				// Increment the current log counter.
					}
					// Otherwise the user can keep cutting this log.
					else
						mArrowSprite.x = newArrowXPosition;	// Move arrow to location just selected.
						mSawdustSprite.x = mArrowSprite.x;
						mSawdustSprite.y = mArrowSprite.y+220;
						//need to create new SawdustSprite() for each cut at the same x location of the cut and y location below log
					
					var pieceLength:Number	= 0; // Length of piece player has just cut (in pixels).
					
					if (iLogNumber == mLastLog)	// Cutting along same log as at the last cut.
						pieceLength = Math.abs(iLocalX - mLastCutX);
					else
					{
						if (iLeftToRight)
							pieceLength = iLocalX;				// First cut from left edge of log.
						else
							pieceLength = iLog.width - iLocalX;	// First cut from right edge of log.
					}

					// Evaluate the piece's acceptance status and record the outcome by setting a 
					// visual marker on each log and also transmit the info to Fathom/TinkerPlots.
					var wasEndPiece:Boolean = false;	// This was not an end piece.
					recordPieceStatus(			
						pieceLength, 			// Piece length
						iLogNumber, 			// Number of log ( 1 is at top).
						wasEndPiece, 			// True if end piece.
						iLeftToRight, 			// True if cutting left to right.
						(iLogNumber != mLastLog),// True if measuring on new log for first time.
						mFuelUsed,				// Raw fuel used at the time of piece creation.
						mLastCutX, 				// Cut before this cut or game end.
						iLocalX);				// X cut location on log. 0 if end piece.
					
					if (isEndPiece)
					{
						// Evaluate the piece's acceptance status and record the outcome by setting a 
						// visual marker on each log and also transmit the info to Fathom/TinkerPlots.
						recordPieceStatus(
							woodRemaining,	// Piece length
							iLogNumber, 	// Number of log ( 1 is at top).
							isEndPiece, 	// True if end piece.
							iLeftToRight, 	// True if cutting left to right.
							false, 			// True if measuring on new log for first time.
							mFuelUsed,		// Raw fuel used at the time of piece creation.
							iLocalX);		// Cut before this cut or game end.
						
						mLeftToRight = !mLeftToRight;	// Was end piece, so next log cuts in opposite direciton.

					}	
					
					mLastLog	= iLogNumber;	// Update cut log counter.
					mLastCutX	= iLocalX;		// Update X position of most recent cut.
				}
			}
			
			// cutLogFreely() performs all cutting operations when the passed in log is cut at 
			// the x position being passed in. The x position is in the coordinate system
			// of the log being cut.
			protected function cutLogFreely(	iLogNumber:uint, 
												iLocalX:Number,
												iTopToBottom:Boolean = true
											):void
			{
				// Don't cut if chainsaw is not running and we're not in practice mode.
				if (mGameLevel != kPracticeLevel)
				{
					if (!mFuelTimer.running)
						return;
				}
				
				var cutWidth:Number	= 1;	// Pixel width of cut.
				
				// Draw cut line vertically.
				var logSprite:SpriteVisualElement= new SpriteVisualElement();	
				logSprite.graphics.lineStyle(cutWidth, kWhite);
				
				if (iTopToBottom)
				{
					logSprite.graphics.moveTo(iLocalX, 0);
					logSprite.graphics.lineTo(iLocalX, mLogArray[iLogNumber-1][0].height);
				}
				else
				{
					logSprite.graphics.moveTo(iLocalX, mLogArray[iLogNumber-1][0].height);
					logSprite.graphics.lineTo(iLocalX, 0);
				}
				
				mLogArray[iLogNumber-1][0].addElement(logSprite); 	// Add cut line to current log's display list.
				++mCutNumber;										// Increment cut number.
				// Add X position of cut and fuel used to log's cut list.
				var cutAndFuelUsed:FuelUsedAtCut = new FuelUsedAtCut(iLocalX, mFuelUsed, mCutNumber);
				mLogArray[iLogNumber-1][2].push(cutAndFuelUsed);			
			}
			
			// onLog1TopMouseOver() is called when the mouse is over log 1's top edge.
			protected function onLog1TopMouseOver(iEvent:MouseEvent):void
			{
				// If mouse is down, cut log at mouseover x position.
				if (iEvent.buttonDown)
				{
					sawdustParticles['startParticleAnim']();//starts emitting particles
					
					if (mGameLevel == kFreeCutLevel)
						cutLogFreely(mLogArray.indexOf(mLogDetails1) + 1, iEvent.localX);	
					else
					{
						// Pass in log top that is to be cut after this log, if any.
						var nextLogTop:BorderContainer	= mCurrentLog < mLogsPerGame ? mLogArray[mCurrentLog][1] : null;
						cutLogInOrder(mCurrentLog, mLog1, mLog1Top, iEvent.localX, mLeftToRight, nextLogTop);	
					}
				}				
			}
					
			// onLog1TopMouseDown() is called when the mouse is clicked on log 1's top edge.
			protected function onLog1TopMouseDown(iEvent:MouseEvent):void
			{
				// If mouse is down, cut log at mouseover x position.
				if (mGameLevel == kFreeCutLevel)
					cutLogFreely(mLogArray.indexOf(mLogDetails1) + 1, iEvent.localX);	
				else
				{
					// Pass in log top that is to be cut after this log, if any.
					var nextLogTop:BorderContainer 	= mCurrentLog < mLogsPerGame ? mLogArray[mCurrentLog][1] : null;
					cutLogInOrder(mCurrentLog, mLog1, mLog1Top, iEvent.localX, mLeftToRight, nextLogTop);	
				}
			}
			
			// onLog2TopMouseOver() is called when the mouse is over log 1's top edge.
			protected function onLog2TopMouseOver(iEvent:MouseEvent):void
			{
				// If mouse is down, cut log at mouseover x position.
				if (iEvent.buttonDown)
				{
					if (mGameLevel == kFreeCutLevel)
						cutLogFreely(mLogArray.indexOf(mLogDetails2) + 1, iEvent.localX);	
					else
					{					
						// Pass in log top that is to be cut after this log, if any.
						var nextLogTop:BorderContainer 	= mCurrentLog < mLogsPerGame ? mLogArray[mCurrentLog][1] : null;
						cutLogInOrder(mCurrentLog, mLog2, mLog2Top, iEvent.localX, mLeftToRight, nextLogTop);	
					}
				}
			}
					
			// onLog2TopMouseDown() is called when the mouse is clicked on log 2's top edge.
			protected function onLog2TopMouseDown(iEvent:MouseEvent):void
			{
				// If mouse is down, cut log at mouseover x position.
				if (mGameLevel == kFreeCutLevel)
					cutLogFreely(mLogArray.indexOf(mLogDetails2) + 1, iEvent.localX);	
				else
				{
					// Pass in log top that is to be cut after this log, if any.
					var nextLogTop:BorderContainer 	= mCurrentLog < mLogsPerGame ? mLogArray[mCurrentLog][1] : null;
					cutLogInOrder(mCurrentLog, mLog2, mLog2Top, iEvent.localX, mLeftToRight, nextLogTop);	
				}
			}
			
			// onLog3TopMouseOver() is called when the mouse is over log 3's slider.
			protected function onLog3TopMouseOver(iEvent:MouseEvent):void
			{
				// If mouse is down, cut log at mouseover x position.
				if (iEvent.buttonDown)
				{
					if (mGameLevel == kFreeCutLevel)
						cutLogFreely(mLogArray.indexOf(mLogDetails3) + 1, iEvent.localX);	
					else
					{				
						// Pass in log top that is to be cut after this log, if any.
						var nextLogTop:BorderContainer 	= mCurrentLog < mLogsPerGame ? mLogArray[mCurrentLog][1] : null;
						cutLogInOrder(mCurrentLog, mLog3, mLog3Top, iEvent.localX, mLeftToRight, nextLogTop);	
					}
				}				
			}
			
			// onLog3TopMouseDown() is called when the mouse is clicked on log 3's slider.
			protected function onLog3TopMouseDown(iEvent:MouseEvent):void
			{
				// If mouse is down, cut log at mouseover x position.
				if (mGameLevel == kFreeCutLevel)
					cutLogFreely(mLogArray.indexOf(mLogDetails3) + 1, iEvent.localX);	
				else
				{
					// Pass in log top that is to be cut after this log, if any.
					var nextLogTop:BorderContainer 	= mCurrentLog < mLogsPerGame ? mLogArray[mCurrentLog][1] : null;
					cutLogInOrder(mCurrentLog, mLog3, mLog3Top, iEvent.localX, mLeftToRight, nextLogTop);	
				}
			}
			
			// onLog4TopMouseOver() is called when the mouse is over log 4's slider.
			protected function onLog4TopMouseOver(iEvent:MouseEvent):void
			{
				// If mouse is down, cut log at mouseover x position.
				if (iEvent.buttonDown)
				{
					if (mGameLevel == kFreeCutLevel)
						cutLogFreely(mLogArray.indexOf(mLogDetails4) + 1, iEvent.localX);	
					else
					{					
						// Pass in log top that is to be cut after this log, if any.
						var nextLogTop:BorderContainer 	= mCurrentLog < mLogsPerGame ? mLogArray[mCurrentLog][1] : null;
						cutLogInOrder(mCurrentLog, mLog4, mLog4Top, iEvent.localX, mLeftToRight, nextLogTop);	
					}
				}
			}
			
			// onLog4TopMouseDown() is called when the mouse is clicked on log 4's slider.
			protected function onLog4TopMouseDown(iEvent:MouseEvent):void
			{
				// If mouse is down, cut log at mouseover x position.
				if (mGameLevel == kFreeCutLevel)
					cutLogFreely(mLogArray.indexOf(mLogDetails4) + 1, iEvent.localX);	
				else
				{
					// Pass in log top that is to be cut after this log, if any.
					var nextLogTop:BorderContainer 	= mCurrentLog < mLogsPerGame ? mLogArray[mCurrentLog][1] : null;
					cutLogInOrder(mCurrentLog, mLog4, mLog4Top, iEvent.localX, mLeftToRight, nextLogTop);	
				}
			}
			
			// onChangePlayerTextInput() is called whenever the text is changed in the mPlayerTextInput control.
			protected function onChangePlayerTextInput(iEvent:TextOperationEvent):void
			{
				mPlayersName = mPlayerTextInput.text;
			}

			// onClickStartButton() is called whenever the start button is pressed.
			protected function onClickStopButton(iEvent:MouseEvent):void
			{
				// Player has pressed End Game to stop game play.
				endGame();
			}

			// onClickChangeLevelButton() allows the user to change the game level.
			protected function onClickChangeLevelButton(event:MouseEvent):void
			{
				chooseGameLevel();
			}
			

			//initialize Tristan's gas tank SWF
			protected function initGasTank():void{
				flashGasTank = mFuelIcon.content as MovieClip;
			}
			
			protected function initLog1():void{
				dynamicLog1 = mDynamicLog.content as MovieClip;
			}
			
			protected function initParticles():void
			{
				sawdustParticles = mSawdustParticles.content as MovieClip;
				sawdustParticles['stopParticleAnim']();
				addEventListener(MouseEvent.MOUSE_MOVE, mouseMoved);
				addEventListener(MouseEvent.ROLL_OUT, mouseReleased);
			}
			
			protected function mouseMoved(event:MouseEvent):void
			{
				sawdustParticles.x = event.stageX;
				sawdustParticles.y = event.stageY;
				sawdustParticles.enabled = false;
				sawdustParticles['mouseFollow'](event);
			}
			protected function mouseReleased(event:MouseEvent):void
			{
				sawdustParticles['stopParticleAnim']();
			}
			protected function mouseOverLog(event:MouseEvent):void
			{
				if(event.buttonDown)
					sawdustParticles['startParticleAnim']();
			}
			protected function mouseOutLog(event:MouseEvent):void
			{
				sawdustParticles['stopParticleAnim']();
			}
		]]>
	</fx:Script>

	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
		<mx:SoundEffect	id="mChainsawSound" source="@Embed(source='../src/assets/Chainsaw Sound Longer.mp3')" repeatCount="{kRepeatSound}"/>
	</fx:Declarations>
	
	<s:Label			id="mGameTitle" x="38" y="19" text="CHAINSAW" fontSize="60" fontWeight="bold" fontFamily="Georgia" color="#669035" verticalAlign="middle" height="49"/>
	<s:Button			id="mStartButton" x="18.5" y="93" label="Start" enabled="true" click="onClickStartButton(event)" fontWeight="bold" fontSize="14" width="90" height="29" mouseDownEffect="{mChainsawSound}"/>
	<s:Button			id="mStopButton" x="18.5" y="484" label="Stop" enabled="false" click="onClickStopButton(event)" fontWeight="bold" fontSize="14" width="90" height="29"/>
	<s:Button			id="mChangeLevelButton" x="18.5" y="519" label="Change Level" enabled="true" click="onClickChangeLevelButton(event)" fontWeight="bold" fontSize="12" width="100" height="29" chromeColor="#4E8E54"/>
	<s:BorderContainer	id="mLogYardContainer" x="15" y="147" width="597" height="324" backgroundColor="#EAD1AA">
		<s:SWFLoader		id="mDynamicLog" x="54" y="38" source="../src/assets/DynamicLog.swf" complete="initLog1()"/>
		<s:BorderContainer	id="mLog1" x="54" y="38" width="337" height="35" backgroundColor="#C09256" borderVisible="false" mouseOver="mouseOverLog(event)" mouseOut="mouseOutLog(event)"/>
		<s:BorderContainer	id="mLog1Top" x="54" y="38" width="337" height="5" backgroundColor="#764D13" borderVisible="false" visible="true" mouseOver="onLog1TopMouseOver(event)" mouseDown="onLog1TopMouseDown(event)" backgroundAlpha="1.0" enabled = "false"/>
		<!-- 	<s:BorderContainer	id="mLog1Bottom" x="56" y="{100+35}" width="337" height="5" backgroundColor="#C09256" borderVisible="false" visible="true" mouseOver="onLog1BottomMouseOver(event)" mouseDown="onLog1BottomMouseDown(event)" backgroundAlpha="0.0"/> -->
		<s:BorderContainer	id="mLog2" x="133" y="107" width="394" height="35" backgroundColor="#C09256" borderVisible="false"/>
		<s:BorderContainer	id="mLog2Top" x="133" y="107" width="394" height="5" backgroundColor="#764D13" borderVisible="false" visible="true" mouseOver="onLog2TopMouseOver(event)" mouseDown="onLog2TopMouseDown(event)" backgroundAlpha="1.0" enabled = "false"/>
		<!-- 	<s:BorderContainer	id="mLog2Bottom" x="135" y="{169+35}" width="394" height="5" backgroundColor="#C09256" borderVisible="false" visible="true" mouseOver="onLog2BottomMouseOver(event)" mouseDown="onLog2BottomMouseDown(event)" backgroundAlpha="0.0" enabled = "false"/> -->
		<s:BorderContainer	id="mLog3" x="70" y="176" width="369" height="35" backgroundColor="#C09256" borderVisible="false"/>
		<s:BorderContainer	id="mLog3Top" x="70" y="176" width="369" height="5" backgroundColor="#764d13" borderVisible="false" visible="true" mouseOver="onLog3TopMouseOver(event)" mouseDown="onLog3TopMouseDown(event)" backgroundAlpha="1.0" enabled = "false"/>
		<s:BorderContainer	id="mLog4" x="94" y="245" width="261" height="35" backgroundColor="#C09256" borderVisible="false"/>
		<s:BorderContainer	id="mLog4Top" x="94" y="245" width="261" height="5" backgroundColor="#764d13" borderVisible="false" visible="true" mouseOver="onLog4TopMouseOver(event)" mouseDown="onLog4TopMouseDown(event)" backgroundAlpha="1.0" enabled = "false"/>
		<s:Label			id="mCutEdgeRightLabel" x="{mLog1Top.x + mLog1Top.width + kCutEdgeRightXOffset}" y="{mLog1Top.y + kCutEdgeLeftYOffset}" text="- Cut Edge" width="60" height="15" fontSize="11" fontWeight="normal" textAlign="left"/>
		<s:Label			id="mCutEdgeLeftLabel" x="{mLog1Top.x + kCutEdgeLeftXOffset}" y="{mLog1Top.y + kCutEdgeRightYOffset}" text="Cut Edge -" width="60" height="15" fontSize="11" fontWeight="normal" textAlign="right"/>
		<s:Label x="-1" y="296" text="PRACTICE LEVEL" width="597" textAlign="center" height="26" fontSize="14" verticalAlign="middle" fontWeight="bold" fontFamily="Georgia" fontStyle="normal" id="mLevelLabel" color="#1C7B56"/>
	</s:BorderContainer>
	<s:Label			id="mAcceptedPiecesLabel" x="399" y="486" text="Number of Accepted Pieces" fontSize="16" fontWeight="bold"/>
	<s:BorderContainer	id="mAcceptedPiecesBox" x="465" y="513" width="75" height="35" borderWeight="2" dropShadowVisible="true">
		<s:Label			id="mAcceptedPiecesValue" x="10" y="8" text="0" fontSize="16" verticalAlign="middle" fontWeight="bold" width="51" textAlign="center" visible="false"/>
	</s:BorderContainer>
	
	<s:Label			id="mReferenceLengthLabel" x="205" y="486" text="Target Length" fontSize="16" fontWeight="bold"/>
	<mx:Image			id="mReferenceLengthImage" x="223" y="515" source="{mLengthImage}"/>
	<mx:Image			id="mReferenceLengthImage2" x="223" y="515" source="{mTapeMeasureImage}"/>
	
	<s:SWFLoader 		id="mFuelIcon" x="497" y="21" width="106" height="118" source="../src/assets/GasTank.swf" complete="initGasTank()"/>
	<s:SWFLoader		id="mSawdustParticles" x="0" y="0" width="100" height="100" source="../src/assets/particles.swf" complete="initParticles()"/>
	
	<s:Label			id="mPlayersNameLabel" x="140.5" y="100.5" text="PLAYER'S NAME:" fontFamily="Arial" fontSize="16" fontWeight="bold" color="#7B9453"/>
	<s:TextInput		id="mPlayerTextInput" x="281" y="94" width="132" text="Player" color="#7B9453" fontSize="16" enabled="true" change="onChangePlayerTextInput(event)" textAlign="left" fontWeight="bold"/>
</s:Application>
